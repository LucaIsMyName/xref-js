{"version":3,"file":"xref.umd.min.js","sources":["../src/prefetch.ts","../src/utils.ts","../src/partials.ts","../src/xref.ts"],"sourcesContent":["import { XrefOptions } from \"./xref\";\n\ninterface PrefetchOptions {\n  event?: string;\n  delay?: number;\n  selector?: string;\n  active?: boolean;\n}\n\nexport class Prefetcher {\n  private cache: Map<string, string> = new Map();\n  private options: PrefetchOptions;\n  private xrefOptions: XrefOptions;\n\n  /**\n   *\n   * @description Initializes the prefetcher\n   * with the given options.\n   */\n  constructor(options: PrefetchOptions, xrefOptions: XrefOptions) {\n    this.options = options;\n    this.xrefOptions = xrefOptions;\n    this.init();\n  }\n\n  /**\n   * @description Initializes the prefetcher by\n   * adding an event listener to the document.\n   */\n  private init() {\n    if (!this.options.active) return;\n    document.addEventListener(this.options.event || \"mouseover\", this.handleEvent.bind(this));\n  }\n\n  /**\n   *\n   * @description Handles the event by checking if the target\n   * is an anchor element and if it should be prefetched.\n   */\n  private handleEvent(event: Event) {\n    const target = event.target as HTMLElement;\n    const link = target.closest(this.options.selector || \"a\") as HTMLAnchorElement | null;\n\n    if (link && this.shouldPrefetch(link)) {\n      setTimeout(() => this.prefetch(link.href), this.options.delay || 100);\n    }\n  }\n\n  /**\n   *\n   * @description Checks if the link should be prefetched.\n   * It should be prefetched if it's an anchor element, it's\n   * not the current page, and it's not already in the cache.\n   */\n  private shouldPrefetch(link: HTMLAnchorElement): boolean {\n    return !!(link.href && link.href.startsWith(window.location.origin) && link.href !== window.location.href && !this.cache.has(link.href));\n  }\n\n  /**\n   *\n   * @description Fetches the content of the given URL\n   * and stores it in the cache. If the fetch fails, it logs\n   * an error to the console.\n   */\n  private async prefetch(url: string) {\n    try {\n      const response = await fetch(url);\n      const text = await response.text();\n      this.cache.set(url, text);\n      this.xrefOptions.debug ? console.log(`Prefetched: ${url}`) : null;\n    } catch (error) {\n      this.xrefOptions.debug ? console.error(\"Failed to prefetch:\" + url, error) : null;\n    }\n  }\n\n  /**\n   *\n   * @description Gets the content of the given URL\n   * from the cache. If the content is not in the cache,\n   * it returns null. Otherwise, it returns the content.\n   * This method is used by the Xref instance to get the\n   * content of a URL before navigating to it.\n   */\n  public getContent(url: string): string | null {\n    return this.cache.get(url) || null;\n  }\n}\n\nexport function initPrefetcher(options: PrefetchOptions, xrefOptions: XrefOptions): Prefetcher {\n  return new Prefetcher(options, xrefOptions);\n}\n","/**\n * @description Convert camelCase to kebab-case\n */\nexport function camelToKebab(str: string): string {\n  return str.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\n/**\n * @description Convert kebab-case to camelCase\n */\nexport function kebabToCamel(str:string): string {\n  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n}\n","import { XrefOptions, TransitionOptions, TransitionState, PartialTransition } from \"./xref\";\nimport { camelToKebab } from \"./utils\";\n\n/**\n * \n * @description Handle partial transitions for a given element \n */\nexport async function handlePartials(partials: PartialTransition[], oldElement: HTMLElement, newElement: HTMLElement, options: XrefOptions, direction: \"in\" | \"out\") {\n  options.debug ? console.log(`Handling partials for ${direction} transition`) : null;\n\n  const partialPromises = partials.flatMap((partial, index) => {\n    const elements = oldElement.querySelectorAll(partial.element);\n    options.debug ? console.log(`Found ${elements.length} elements matching selector: ${partial.element}`) : null;\n\n    return Array.from(elements).map((element) => {\n      const mergedOptions = mergeOptions(partial, options.transition, index);\n      let transitionState = direction === \"out\" ? partial.out : partial.in;\n\n      // If the transition for the current direction is not defined, reverse the other direction\n      if (!transitionState) {\n        const oppositeTransition = direction === \"out\" ? partial.in : partial.out;\n        if (oppositeTransition) {\n          transitionState = reverseTransition(oppositeTransition);\n        }\n      }\n\n      if (transitionState) {\n        if (direction === \"in\") {\n          element.style.removeProperty(\"visibility\");\n        }\n        return applyPartialTransition(element as HTMLElement, transitionState, mergedOptions, direction);\n      }\n      return Promise.resolve();\n    });\n  });\n\n  await Promise.all(partialPromises);\n}\n\n/**\n * \n * @description Merge partial transition options with global transition options\n */\nfunction mergeOptions(partial: PartialTransition, globalTransition: TransitionOptions | undefined, index: number): TransitionOptions {\n  const globalPartial = globalTransition?.partials?.[index] || {};\n  return {\n    ...globalTransition,\n    ...globalPartial,\n    duration: partial.duration ?? globalTransition?.duration,\n    delay: partial.delay ?? globalTransition?.delay,\n    easing: partial.easing ?? globalTransition?.easing,\n  };\n}\n\n/**\n * \n * @description Reverse the transition state\n */\nfunction reverseTransition(transition: TransitionState): TransitionState {\n  return {\n    from: transition.to,\n    to: transition.from,\n  };\n}\n\n/**\n * \n * @description Hide partial elements\n */\nexport function hidePartials(partials: PartialTransition[], element: HTMLElement) {\n  partials.forEach((partial) => {\n    const elements = element.querySelectorAll(partial.element);\n    elements.forEach((el: HTMLElement | any) => {\n      el.style.visibility = \"hidden\";\n    });\n  });\n}\n\n/**\n * \n * @description Show partial elements\n */\nexport function showPartials(partials: PartialTransition[], element: HTMLElement) {\n  partials.forEach((partial) => {\n    const elements = element.querySelectorAll(partial.element);\n    elements.forEach((el: HTMLElement | any) => {\n      el.style.visibility = \"visible\";\n    });\n  });\n}\n\n/**\n * @description Apply partial transition to an element\n * */\nasync function applyPartialTransition(element: HTMLElement, transitionState: TransitionState, options: TransitionOptions, direction: \"in\" | \"out\"): Promise<void> {\n  return new Promise((resolve) => {\n    const duration = options.duration || 300;\n    const delay = options.delay ?? 0;\n    const easing = options.easing || \"ease-in-out\";\n\n    const keyframeName = createKeyframes(transitionState, direction);\n    const animationCSS = `${keyframeName} ${duration}ms ${easing} ${delay}ms forwards`;\n\n    element.style.setProperty(\"animation\", animationCSS);\n    console.log(`Applied ${direction} animation to partial: ${animationCSS}`);\n    console.log(\"Current partial element style:\", element.style.cssText);\n\n    // Force a reflow to ensure the animation is applied immediately\n    void element.offsetWidth;\n\n    const cleanup = () => {\n      console.log(`Animation end event fired for ${direction} transition on partial: ${element.tagName}`);\n      element.style.removeProperty(\"animation\");\n\n      // Remove the keyframe immediately after the animation is complete\n      removeKeyframes(keyframeName);\n\n      if (direction === \"in\") {\n        Object.entries(transitionState.to || {}).forEach(([key, value]) => {\n          element.style.setProperty(camelToKebab(key), value as string);\n        });\n      }\n      console.log(`Cleaned up ${direction} animation for partial: ${element.tagName}`);\n      console.log(\"Current partial element style after cleanup:\", element.style.cssText);\n\n      resolve();\n    };\n\n    element.addEventListener(\"animationend\", cleanup, { once: true });\n  });\n}\n\nfunction createKeyframes(transitionState: TransitionState, direction: \"in\" | \"out\"): string {\n  const { from, to } = transitionState;\n  let randomId = Math.random().toString(36).substr(2, 9);\n  const keyframeName = `xref-partial-${direction}-${randomId}`;\n\n  const keyframeCSS = `@keyframes ${keyframeName} {\n    from {\n      ${Object.entries(from || {})\n        .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n        .join(\" \")}\n    }\n    to {\n      ${Object.entries(to || {})\n        .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n        .join(\" \")}\n    }\n  }`;\n\n  const styleElement = document.createElement(\"style\");\n  styleElement.textContent = keyframeCSS;\n  styleElement.setAttribute(keyframeName, '');\n  document.head.appendChild(styleElement);\n\n  return keyframeName;\n}\n\nfunction removeKeyframes(keyframeName: string) {\n  // this is bad implementation, remove by keyframeName not :last-of-type selector\n  // const styleElement = document.querySelector(`style:not([data-xref=\"true\"]):last-of-type`);\n\n  const styleElement = document.querySelector(`style[${keyframeName}]`);\n  if (styleElement) {\n    styleElement.remove();\n  }\n}\n","import { Prefetcher, initPrefetcher } from \"./prefetch\";\nimport { handlePartials, hidePartials, showPartials } from \"./partials\";\nimport { camelToKebab } from \"./utils\";\n\nexport interface XrefOptions {\n  debug?: boolean;\n  updateHead?: boolean;\n  transition?: TransitionOptions;\n  prefetch?: PrefetchOptions;\n  head?: HeadOptions;\n}\n\nexport interface HeadOptions {\n  update?: boolean;\n  retrigger?: {\n    css?: boolean;\n    js?: boolean;\n    include?: string | RegExp;\n    exclude?: string | RegExp;\n  };\n}\nexport interface PrefetchOptions {\n  active: boolean;\n  delay: number;\n  event: string;\n  selector?: string;\n}\n\nexport interface TransitionOptions {\n  duration?: number;\n  delay?: number;\n  easing?: string;\n  timeline?: \"sequential\" | \"parallel\";\n  in?: TransitionState;\n  out?: TransitionState;\n  callback?: TransitionCallbacks;\n  state?: AnimationState;\n  swapHtml?: string;\n  partials?: PartialTransition[];\n}\n\nexport interface PartialTransition {\n  element: string;\n  duration?: number;\n  delay?: number;\n  easing?: string;\n  in?: TransitionState;\n  out?: TransitionState;\n}\n\nexport interface TransitionState {\n  from?: Record<string, string | number>;\n  to?: Record<string, string | number>;\n}\n\nexport interface AnimationState {\n  started: boolean;\n  playing: boolean;\n  paused: boolean;\n  finished: boolean;\n}\n\nexport interface TransitionCallbacks {\n  onEnter?: () => void;\n  onStart?: () => void;\n  onPlay?: () => void;\n  onPause?: () => void;\n  onFinish?: () => void;\n}\n\n/**\n * The main Xref class that handles\n * navigation and transitions.\n *\n * @returns The Xref instance.\n *\n * @description This is the main class that handles navigation and transitions.\n * It intercepts clicks on internal links, fetches the content of the linked page,\n * updates the document head and body, and performs transitions between the\n * old and new content. It also handles popstate events to support back\n * and forward navigation.\n */\nclass Xref {\n  private options: XrefOptions;\n  private styleElement: HTMLStyleElement;\n  private transitionCounter: number = 0;\n  private prefetcher: Prefetcher | null = null;\n  private animationState: AnimationState;\n\n  /**\n   * @description This is the constructor of the Xref class.\n   * It initializes the Xref instance with the given options,\n   * creates a style element to store the keyframes for transitions,\n   * and sets the initial animation state.\n   */\n  constructor(options: XrefOptions = {}) {\n    this.options = {\n      updateHead: true,\n      ...options,\n    };\n    this.styleElement = document.createElement(\"style\");\n    this.styleElement.setAttribute(\"data-xref\", \"true\");\n    document.head.appendChild(this.styleElement);\n    this.animationState = {\n      started: false,\n      playing: true,\n      paused: false,\n      finished: false,\n      ...(this.options.transition?.state as Partial<AnimationState>),\n    };\n    this.init();\n  }\n\n  /**\n   * @description This method initializes the Xref instance\n   * by intercepting clicks on internal links, handling popstate events,\n   * and initializing the prefetcher if prefetching is enabled.\n   */\n  private init() {\n    this.options.debug ? console.log(\"started -> init() Method\") : null;\n\n    this.interceptClicks();\n    this.handlePopState();\n\n    if (this.options.prefetch && this.options.prefetch.active) {\n      this.prefetcher = initPrefetcher(this.options.prefetch, this.options);\n    }\n  }\n\n  private currentKeyframeName: string | null = null;\n\n  /**\n   * @description This method creates keyframes\n   * for the given transition state\n   * and direction.\n   */\n  private createKeyframes(transitionState: TransitionState, direction: \"in\" | \"out\"): string {\n    const { from, to } = transitionState;\n    const keyframeName = `xref-${direction}-${++this.transitionCounter}`;\n\n    let keyframeCSS = `@keyframes ${keyframeName} {\n      from {\n        ${Object.entries(from || {})\n          .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n      to {\n        ${Object.entries(to || {})\n          .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n    }`;\n\n    this.options.debug ? console.log(\"Creating keyframe:\" + keyframeName) : null;\n    this.options.debug ? console.log(\"Keyframe CSS:\" + keyframeCSS) : null;\n\n    // Remove the previous keyframe if it exists\n    if (this.currentKeyframeName) {\n      this.removeKeyframes(this.currentKeyframeName);\n    }\n\n    // Append the new keyframe to the style element's content\n    this.styleElement.textContent = keyframeCSS;\n    this.currentKeyframeName = keyframeName;\n\n    this.options.debug ? console.log(\"Keyframe \" + keyframeName + \"appended to <style> element\") : null;\n    this.options.debug ? console.log(\"Current <style> content: \" + this.styleElement.textContent) : null;\n\n    return keyframeName;\n  }\n\n  /**\n   * @param keyframeName\n   * @description This method removes the keyframes\n   * with the given name from the style element.\n   */\n  private removeKeyframes(keyframeName: string) {\n    this.options.debug ? console.log(\"Removing keyframe: \" + keyframeName) : null;\n    this.styleElement.textContent = \"\";\n    this.options.debug ? console.log(\"Keyframe\" + keyframeName + \"removed\") : null;\n    this.options.debug ? console.log(\"Current <style> content after removal:\" + this.styleElement.textContent) : null;\n    this.currentKeyframeName = null;\n  }\n\n  /**\n   * @description This method intercepts clicks\n   * on internal links and prevents the default\n   * browser navigation behavior.\n   */\n  private interceptClicks() {\n    this.options.debug ? console.log(\"started -> interceptClicks() Method\") : null;\n\n    document.addEventListener(\"click\", (event) => {\n      const target = event.target as HTMLElement;\n      const anchor = target.closest(\"a\");\n      if (anchor && this.shouldIntercept(anchor as HTMLAnchorElement)) {\n        event.preventDefault();\n        this.runCallback(\"onEnter\");\n        this.navigate(anchor.href);\n      }\n    });\n  }\n\n  /**\n   * @description This method checks if the\n   * anchor should be intercepted based on\n   * the current URL and the anchor's href.\n   */\n  private shouldIntercept(anchor: HTMLAnchorElement): boolean {\n    this.options.debug ? console.log(\"started -> shouldIntercept() Method\") : null;\n\n    const currentUrl = new URL(window.location.href);\n    const linkUrl = new URL(anchor.href);\n\n    // Check if it's an internal link\n    const isSameOrigin = linkUrl.origin === currentUrl.origin;\n\n    // Check if it's not the current page or just a hash change\n    const isSamePage = linkUrl.pathname === currentUrl.pathname && linkUrl.search === currentUrl.search;\n    const isJustHashChange = isSamePage && linkUrl.hash !== currentUrl.hash;\n\n    // Intercept only if it's an internal link and not the same page or just a hash change\n    return isSameOrigin && !isSamePage && !isJustHashChange;\n  }\n\n  /**\n   * @description This method handles popstate events\n   * to support back and forward navigation.\n   */\n  private handlePopState() {\n    this.options.debug ? console.log(\"started -> handlePopState() Method\") : null;\n\n    window.addEventListener(\"popstate\", () => {\n      this.navigate(window.location.href, false);\n    });\n  }\n\n  /**\n   * @description This method navigates to the given URL\n   * and updates the page content. If prefetching is enabled\n   * and the content is already prefetched, it uses the\n   * prefetched content instead of fetching it again.\n   * If pushState is true, it updates the browser history.\n   */\n  public async navigate(url: string, pushState: boolean = true) {\n    this.options.debug ? console.log(\"started -> navigate() Method\") : null;\n\n    try {\n      let content: string | null = null;\n      if (this.prefetcher) {\n        content = this.prefetcher.getContent(url);\n      }\n\n      if (!content) {\n        content = await this.fetchPage(url);\n      }\n\n      if (content) {\n        if (pushState) {\n          history.pushState(null, \"\", url);\n        }\n        this.updatePage(content);\n      }\n    } catch (error) {\n      this.options.debug ? console.error(\"Navigation failed:\", error) : null;\n    }\n  }\n\n  /**\n   * @description This method fetches the content of the given URL\n   * and returns it as a string. It throws an error if the request fails.\n   */\n  private async fetchPage(url: string): Promise<string> {\n    this.options.debug ? console.log(\"started -> fetchPage() Method\") : null;\n\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    return await response.text();\n  }\n\n  /**\n   * @description This method updates the page content\n   * with the new content fetched from the server.\n   * It updates the head and body of the document\n   * based on the new content.\n   */\n  private async updatePage(content: string) {\n    this.options.debug ? console.log(\"started -> updatePage() Method\") : null;\n\n    const parser = new DOMParser();\n    const newDoc = parser.parseFromString(content, \"text/html\");\n\n    // Update the body content\n    await this.updateBody(newDoc);\n\n    // Update the head content\n    this.updateHead(newDoc);\n\n    // Handle all scripts (both in head and body)\n    this.handleScripts(document, newDoc);\n\n    // Trigger a custom event to signal that the page has been updated\n    const event = new CustomEvent(\"xrefPageUpdated\");\n    document.dispatchEvent(event);\n\n    window.scrollTo(0, 0);\n  }\n\n  /**\n   * @description This method updates the head of the document\n   * with the new head from the fetched content. It updates\n   * the title and other head elements based on the new content.\n   */\n  private updateHead(newDoc: Document) {\n    this.options.debug ? console.log(\"started -> updateHead() Method\") : null;\n\n    const oldHead = document.head;\n    const newHead = newDoc.head;\n\n    // Always update the title\n    document.title = newDoc.title;\n\n    if (this.options.head?.update === false) {\n      return;\n    }\n\n    // Remove old elements except our style element and title\n    Array.from(oldHead.children).forEach((child) => {\n      if (child !== this.styleElement && child.tagName !== \"TITLE\") {\n        child.remove();\n      }\n    });\n\n    // Add new elements\n    Array.from(newHead.children).forEach((child) => {\n      if (/*child.tagName !== \"STYLE\" &&*/ child.tagName !== \"TITLE\") {\n        const newChild = child.cloneNode(true) as HTMLElement;\n        oldHead.appendChild(newChild);\n        this.retriggerElement(newChild);\n      }\n    });\n\n    this.options.debug ? console.log(\"Head updated, xref style element preserved\") : null;\n  }\n\n  private retriggerElement(element: HTMLElement) {\n    const { retrigger } = this.options.head || {};\n    if (!retrigger) return;\n\n    const shouldRetrigger = (el: HTMLElement): boolean => {\n      if (retrigger.include && !el.matches(retrigger.include.toString())) return false;\n      if (retrigger.exclude && el.matches(retrigger.exclude.toString())) return false;\n      return true;\n    };\n\n    if (element.tagName === \"LINK\" && retrigger.css && shouldRetrigger(element)) {\n      const link = element as HTMLLinkElement;\n      link.href = link.href.split(\"?\")[0] + \"?t=\" + new Date().getTime();\n    } else if (element.tagName === \"SCRIPT\" && retrigger.js && shouldRetrigger(element)) {\n      const script = element as HTMLScriptElement;\n      const newScript = document.createElement(\"script\");\n      Array.from(script.attributes).forEach((attr) => newScript.setAttribute(attr.name, attr.value));\n      newScript.textContent = script.textContent;\n      script.parentNode?.replaceChild(newScript, script);\n    }\n  }\n\n  /**\n   * @description This method updates the body of the document\n   * with the new body from the fetched content. It updates\n   * the content of the swapHtml element based on the new content.\n   * It also performs the transition between the old and new content.\n   */\n  private async updateBody(newDoc: Document) {\n    this.options.debug ? console.log(\"started -> updateBody() Method\") : null;\n\n    const swapHtml = this.options.transition?.swapHtml || \"body\";\n    const oldElement = document.querySelector(swapHtml);\n    const newElement = newDoc.querySelector(swapHtml);\n\n    if (!oldElement || !newElement) {\n      this.options.debug ? console.error(`Element not found: ${swapHtml}`) : null;\n      return;\n    }\n\n    await this.performTransition(oldElement as HTMLElement, newElement as HTMLElement);\n\n    // Update content of swapHtml\n    oldElement.innerHTML = newElement.innerHTML;\n    Array.from(newElement.attributes).forEach((attr) => {\n      if (attr.name !== \"style\") {\n        oldElement.setAttribute(attr.name, attr.value);\n      }\n    });\n  }\n\n  /**\n   * @description This method handles the scripts in the new content\n   * by comparing them with the old content and adding or removing\n   * scripts as needed. It also re-executes inline scripts.\n   * This is necessary to ensure that the scripts are executed\n   * when the new content is added to the document.\n   */\n  private handleScripts(oldDoc: Document, newDoc: Document) {\n    const handleScriptsInElement = (oldElement: Element, newElement: Element) => {\n      const oldScripts = Array.from(oldElement.querySelectorAll(\"script\"));\n      const newScripts = Array.from(newElement.querySelectorAll(\"script\"));\n\n      // Remove scripts that are in the old page but not in the new page\n      oldScripts.forEach((script) => {\n        const matchingNewScript = newScripts.find((newScript) => newScript.src === script.src && newScript.textContent === script.textContent);\n        if (!matchingNewScript) {\n          script.remove();\n        }\n      });\n\n      // Add new scripts or re-execute existing ones\n      newScripts.forEach((newScript) => {\n        const existingScript = oldScripts.find((script) => script.src === newScript.src && script.textContent === script.textContent);\n\n        if (existingScript) {\n          // Re-execute inline script\n          if (!newScript.src) {\n            const scriptElement = document.createElement(\"script\");\n            Array.from(newScript.attributes).forEach((attr) => scriptElement.setAttribute(attr.name, attr.value));\n            scriptElement.textContent = newScript.textContent;\n            existingScript.parentNode?.replaceChild(scriptElement, existingScript);\n          }\n          // For external scripts, we create a new script element to force a reload\n          else {\n            const scriptElement = document.createElement(\"script\");\n            Array.from(newScript.attributes).forEach((attr) => scriptElement.setAttribute(attr.name, attr.value));\n            existingScript.parentNode?.replaceChild(scriptElement, existingScript);\n          }\n        } else {\n          // Add new script\n          const scriptElement = document.createElement(\"script\");\n          Array.from(newScript.attributes).forEach((attr) => scriptElement.setAttribute(attr.name, attr.value));\n          scriptElement.textContent = newScript.textContent;\n          oldElement.appendChild(scriptElement);\n        }\n      });\n    };\n\n    // Handle scripts in the head\n    handleScriptsInElement(oldDoc.head, newDoc.head);\n\n    // Handle scripts in the body\n    handleScriptsInElement(oldDoc.body, newDoc.body);\n  }\n\n  /**\n   * @description This method performs the transition\n   * between the old and new content by applying the\n   * in and out transitions to the elements.\n   * It also handles the transition timeline, duration,\n   * delay, and easing.\n   */\n  private async performTransition(oldElement: HTMLElement, newElement: HTMLElement) {\n    this.options.debug ? console.log(\"Started performTransition\") : null;\n    const transitionOptions = this.options.transition || {};\n    const duration = transitionOptions.duration || 300;\n    const delay = transitionOptions.delay || 0;\n    const easing = transitionOptions.easing || \"ease-in-out\";\n\n    let outTransition = transitionOptions.out;\n    let inTransition = transitionOptions.in;\n\n    this.setTransitionState(\"started\", true);\n    this.runCallback(\"onStart\");\n\n    // Get partials outside swapHtml\n    const partialsOutsideSwapHtml = this.getPartialsOutsideSwapHtml();\n\n    // 1. Animate partials \"out\"\n    if (partialsOutsideSwapHtml.length > 0) {\n      this.options.debug ? console.log(\"Applying partial out transitions\") : null;\n      const partialsOutPromise = handlePartials(partialsOutsideSwapHtml, document.body, document.body, this.options, \"out\");\n\n      // Wait for the longest partial out animation to complete\n      await partialsOutPromise;\n\n      // Hide partials after out animations\n      hidePartials(partialsOutsideSwapHtml, document.body);\n    }\n\n    // 2. Animate swapHtml out\n    if (outTransition) {\n      this.options.debug ? console.log(\"Applying main out transition\") : null;\n      await this.applyTransition(oldElement, outTransition, duration, delay, easing, \"out\");\n    }\n\n    // Update content of swapHtml\n    oldElement.innerHTML = newElement.innerHTML;\n    Array.from(newElement.attributes).forEach((attr) => {\n      if (attr.name !== \"style\") {\n        oldElement.setAttribute(attr.name, attr.value);\n      }\n    });\n\n    // 3. Animate swapHtml in\n    if (inTransition) {\n      this.options.debug ? console.log(\"Applying main in transition\") : null;\n      await this.applyTransition(oldElement, inTransition, duration, delay, easing, \"in\");\n    }\n\n    // 4. Animate partials \"in\"\n    if (partialsOutsideSwapHtml.length > 0) {\n      hidePartials(partialsOutsideSwapHtml, document.body);\n      await handlePartials(partialsOutsideSwapHtml, document.body, document.body, this.options, \"in\");\n    }\n\n    // 5. Partials visible and DOM is ready with new Page\n    this.setTransitionState(\"finished\", true);\n    this.runCallback(\"onFinish\");\n\n    window.scrollTo(0, 0);\n  }\n\n  private getPartialsOutsideSwapHtml(): PartialTransition[] {\n    const swapHtml = this.options.transition?.swapHtml || \"body\";\n    const swapHtmlElement = document.querySelector(swapHtml);\n\n    return (this.options.transition?.partials || []).filter((partial) => {\n      const elements = document.querySelectorAll(partial.element);\n      return Array.from(elements).every((el) => !swapHtmlElement?.contains(el));\n    });\n  }\n\n  /**\n   * @description This method reverses the given transition\n   * by swapping the from and to states. This is useful\n   * for creating the \"out\" transition from the \"in\" transition.\n   */\n  private reverseTransition(transition: TransitionState): TransitionState {\n    return {\n      from: transition.to,\n      to: transition.from,\n    };\n  }\n\n  /**\n   * @description This method applies the transition to the element\n   * by creating the keyframes, setting the animation properties,\n   * and cleaning up after the animation is complete.\n   */\n  private applyTransition(element: HTMLElement, transitionState: TransitionState, duration: number, delay: number, easing: string, direction: \"in\" | \"out\"): Promise<void> {\n    return new Promise((resolve) => {\n      this.options.debug ? console.log(`Applying ${direction} transition`) : null;\n      const keyframeName = this.createKeyframes(transitionState, direction);\n      const animationCSS = `${keyframeName} ${duration}ms ${easing} ${delay}ms forwards`;\n\n      element.style.setProperty(\"animation\", animationCSS);\n      this.options.debug ? console.log(`Applied ${direction} animation: ${animationCSS}`) : null;\n      this.options.debug ? console.log(\"Current element style:\", element.style.cssText) : null;\n\n      // Force a reflow to ensure the animation is applied immediately\n      void element.offsetWidth;\n\n      const cleanup = () => {\n        this.options.debug ? console.log(`Animation end event fired for ${direction} transition`) : null;\n        element.style.removeProperty(\"animation\");\n\n        // Remove the keyframe immediately after the animation is complete\n        this.removeKeyframes(keyframeName);\n\n        if (direction === \"in\") {\n          Object.entries(transitionState.to || {}).forEach(([key, value]) => {\n            element.style.setProperty(camelToKebab(key), value as string);\n          });\n        }\n        this.options.debug ? console.log(`Cleaned up ${direction} animation`) : null;\n        this.options.debug ? console.log(\"Current element style after cleanup:\", element.style.cssText) : null;\n\n        resolve();\n      };\n\n      element.addEventListener(\"animationend\", cleanup, { once: true });\n    });\n  }\n\n  /**\n   * @description This method sets the transition state\n   * based on the given key and value. This is useful\n   * for tracking the state of the transition.\n   */\n  private setTransitionState(key: keyof AnimationState, value: boolean) {\n    this.animationState[key] = value;\n  }\n\n  /**\n   *\n   * @description This method runs the callback with the given name\n   * if it exists in the transition options. This is useful for\n   * running custom code at different stages of the transition.\n   */\n  private runCallback(callbackName: keyof TransitionCallbacks) {\n    const callback = this.options.transition?.callback?.[callbackName];\n    if (callback && typeof callback === \"function\") {\n      callback();\n    }\n  }\n\n  /**\n   * @description This method starts the transition\n   * and sets the animation state accordingly.\n   */\n  public startTransition() {\n    this.setTransitionState(\"started\", true);\n    this.setTransitionState(\"playing\", true);\n    this.setTransitionState(\"paused\", false);\n    this.setTransitionState(\"finished\", false);\n    this.runCallback(\"onStart\");\n    this.runCallback(\"onPlay\");\n  }\n\n  /**\n   * @description This method pauses the transition\n   * and sets the animation state accordingly.\n   */\n  public pauseTransition() {\n    if (this.animationState.playing) {\n      this.setTransitionState(\"playing\", false);\n      this.setTransitionState(\"paused\", true);\n      this.runCallback(\"onPause\");\n\n      // Pause transition\n      const element = document.querySelector(this.options.transition?.swapHtml || \"body\");\n      if (element instanceof HTMLElement) {\n        element.style.animationPlayState = \"paused\";\n      }\n    }\n  }\n\n  /**\n   * @description This method resumes the transition\n   * and sets the animation state accordingly.\n   */\n  public resumeTransition() {\n    if (this.animationState.paused) {\n      this.setTransitionState(\"playing\", true);\n      this.setTransitionState(\"paused\", false);\n      this.runCallback(\"onPlay\");\n\n      // Play transition\n      const element = document.querySelector(this.options.transition?.swapHtml || \"body\");\n      if (element instanceof HTMLElement) {\n        element.style.animationPlayState = \"running\";\n      }\n    }\n  }\n\n  /**\n   * @description This method finishes the transition\n   * and cleans up the animation\n   * */\n  public finishTransition() {\n    this.setTransitionState(\"playing\", false);\n    this.setTransitionState(\"paused\", false);\n    this.setTransitionState(\"finished\", true);\n    this.runCallback(\"onFinish\");\n  }\n}\n\n/**\n * @description This function creates a new Xref instance\n * with the given options and returns it. This is the main\n * entry point for using Xref in a project.\n */\nfunction xref(options: XrefOptions = {}): Xref {\n  return new Xref(options);\n}\n\nexport default xref;\n"],"names":["Prefetcher","constructor","options","xrefOptions","this","cache","Map","init","active","document","addEventListener","event","handleEvent","bind","link","target","closest","selector","shouldPrefetch","setTimeout","prefetch","href","delay","startsWith","window","location","origin","has","url","response","fetch","text","set","debug","console","log","error","getContent","get","camelToKebab","str","replace","toLowerCase","async","handlePartials","partials","oldElement","newElement","direction","partialPromises","flatMap","partial","index","elements","querySelectorAll","element","length","Array","from","map","mergedOptions","globalTransition","globalPartial","_a","Object","assign","duration","_b","_c","easing","_d","mergeOptions","transition","transitionState","out","in","oppositeTransition","to","style","removeProperty","Promise","resolve","keyframeName","randomId","Math","random","toString","substr","keyframeCSS","entries","key","value","join","styleElement","createElement","textContent","setAttribute","head","appendChild","createKeyframes","animationCSS","setProperty","cssText","offsetWidth","cleanup","tagName","querySelector","remove","removeKeyframes","forEach","once","applyPartialTransition","all","hidePartials","el","visibility","Xref","transitionCounter","prefetcher","currentKeyframeName","updateHead","animationState","started","playing","paused","finished","state","interceptClicks","handlePopState","anchor","shouldIntercept","preventDefault","runCallback","navigate","currentUrl","URL","linkUrl","isSameOrigin","isSamePage","pathname","search","isJustHashChange","hash","pushState","content","fetchPage","history","updatePage","ok","Error","status","newDoc","DOMParser","parseFromString","updateBody","handleScripts","CustomEvent","dispatchEvent","scrollTo","oldHead","newHead","title","update","children","child","newChild","cloneNode","retriggerElement","retrigger","shouldRetrigger","include","matches","exclude","css","split","Date","getTime","js","script","newScript","attributes","attr","name","parentNode","replaceChild","swapHtml","performTransition","innerHTML","oldDoc","handleScriptsInElement","oldScripts","newScripts","find","src","existingScript","scriptElement","body","transitionOptions","outTransition","inTransition","setTransitionState","partialsOutsideSwapHtml","getPartialsOutsideSwapHtml","partialsOutPromise","applyTransition","swapHtmlElement","filter","every","contains","reverseTransition","callbackName","callback","startTransition","pauseTransition","HTMLElement","animationPlayState","resumeTransition","finishTransition"],"mappings":"2OASaA,EAUX,WAAAC,CAAYC,EAA0BC,GAT9BC,KAAAC,MAA6B,IAAIC,IAUvCF,KAAKF,QAAUA,EACfE,KAAKD,YAAcA,EACnBC,KAAKG,MACN,CAMO,IAAAA,GACDH,KAAKF,QAAQM,QAClBC,SAASC,iBAAiBN,KAAKF,QAAQS,OAAS,YAAaP,KAAKQ,YAAYC,KAAKT,MACpF,CAOO,WAAAQ,CAAYD,GAClB,MACMG,EADSH,EAAMI,OACDC,QAAQZ,KAAKF,QAAQe,UAAY,KAEjDH,GAAQV,KAAKc,eAAeJ,IAC9BK,YAAW,IAAMf,KAAKgB,SAASN,EAAKO,OAAOjB,KAAKF,QAAQoB,OAAS,IAEpE,CAQO,cAAAJ,CAAeJ,GACrB,SAAUA,EAAKO,OAAQP,EAAKO,KAAKE,WAAWC,OAAOC,SAASC,SAAWZ,EAAKO,OAASG,OAAOC,SAASJ,MAASjB,KAAKC,MAAMsB,IAAIb,EAAKO,MACnI,CAQO,cAAMD,CAASQ,GACrB,IACE,MAAMC,QAAiBC,MAAMF,GACvBG,QAAaF,EAASE,OAC5B3B,KAAKC,MAAM2B,IAAIJ,EAAKG,GACpB3B,KAAKD,YAAY8B,OAAQC,QAAQC,IAAI,eAAeP,IACrD,CAAC,MAAOQ,GACPhC,KAAKD,YAAY8B,OAAQC,QAAQE,MAAM,sBAAwBR,EAAKQ,EACrE,CACF,CAUM,UAAAC,CAAWT,GAChB,OAAOxB,KAAKC,MAAMiC,IAAIV,IAAQ,IAC/B,EClFG,SAAUW,EAAaC,GAC3B,OAAOA,EAAIC,QAAQ,qBAAsB,SAASC,aACpD,CCEOC,eAAeC,EAAeC,EAA+BC,EAAyBC,EAAyB7C,EAAsB8C,GAC1I9C,EAAQ+B,OAAQC,QAAQC,IAAI,yBAAyBa,gBAErD,MAAMC,EAAkBJ,EAASK,SAAQ,CAACC,EAASC,KACjD,MAAMC,EAAWP,EAAWQ,iBAAiBH,EAAQI,SAGrD,OAFArD,EAAQ+B,OAAQC,QAAQC,IAAI,SAASkB,EAASG,sCAAsCL,EAAQI,WAErFE,MAAMC,KAAKL,GAAUM,KAAKJ,IAC/B,MAAMK,EA4BZ,SAAsBT,EAA4BU,EAAiDT,eACjG,MAAMU,GAA6C,QAA7BC,EAAAF,aAAgB,EAAhBA,EAAkBhB,gBAAW,IAAAkB,OAAA,EAAAA,EAAAX,KAAU,GAC7D,OACKY,OAAAC,OAAAD,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAJ,GACAC,GAAa,CAChBI,SAA0B,QAAhBC,EAAAhB,EAAQe,gBAAQ,IAAAC,EAAAA,EAAIN,eAAAA,EAAkBK,SAChD5C,MAAwB,QAAjB8C,EAAAjB,EAAQ7B,aAAS,IAAA8C,EAAAA,EAAAP,aAAgB,EAAhBA,EAAkBvC,MAC1C+C,eAAQC,EAAAnB,EAAQkB,sBAAUR,aAAA,EAAAA,EAAkBQ,QAEhD,CArC4BE,CAAapB,EAASjD,EAAQsE,WAAYpB,GAChE,IAAIqB,EAAgC,QAAdzB,EAAsBG,EAAQuB,IAAMvB,EAAQwB,GAGlE,IAAKF,EAAiB,CACpB,MAAMG,EAAmC,QAAd5B,EAAsBG,EAAQwB,GAAKxB,EAAQuB,IAClEE,IACFH,EAqCD,CACLf,MAFuBc,EApCmBI,GAsCzBC,GACjBA,GAAIL,EAAWd,MArCZ,CAkCP,IAA2Bc,EAhCrB,OAAIC,GACgB,OAAdzB,GACFO,EAAQuB,MAAMC,eAAe,cAkEvCpC,eAAsCY,EAAsBkB,EAAkCvE,EAA4B8C,GACxH,OAAO,IAAIgC,SAASC,UAClB,MAAMf,EAAWhE,EAAQgE,UAAY,IAC/B5C,EAAqB,QAAbyC,EAAA7D,EAAQoB,aAAK,IAAAyC,EAAAA,EAAI,EACzBM,EAASnE,EAAQmE,QAAU,cAE3Ba,EAgCV,SAAyBT,EAAkCzB,GACzD,MAAMU,KAAEA,EAAImB,GAAEA,GAAOJ,EACrB,IAAIU,EAAWC,KAAKC,SAASC,SAAS,IAAIC,OAAO,EAAG,GACpD,MAAML,EAAe,gBAAgBlC,KAAamC,IAE5CK,EAAc,cAAcN,0BAE5BlB,OAAOyB,QAAQ/B,GAAQ,IACtBC,KAAI,EAAE+B,EAAKC,KAAW,GAAGpD,EAAamD,OAASC,OAC/CC,KAAK,gCAGN5B,OAAOyB,QAAQZ,GAAM,IACpBlB,KAAI,EAAE+B,EAAKC,KAAW,GAAGpD,EAAamD,OAASC,OAC/CC,KAAK,mBAINC,EAAepF,SAASqF,cAAc,SAK5C,OAJAD,EAAaE,YAAcP,EAC3BK,EAAaG,aAAad,EAAc,IACxCzE,SAASwF,KAAKC,YAAYL,GAEnBX,CACT,CAxDyBiB,CAAgB1B,EAAiBzB,GAChDoD,EAAe,GAAGlB,KAAgBhB,OAAcG,KAAU/C,eAEhEiC,EAAQuB,MAAMuB,YAAY,YAAaD,GACvClE,QAAQC,IAAI,WAAWa,2BAAmCoD,KAC1DlE,QAAQC,IAAI,iCAAkCoB,EAAQuB,MAAMwB,SAGvD/C,EAAQgD,YAEb,MAAMC,EAAU,KACdtE,QAAQC,IAAI,iCAAiCa,4BAAoCO,EAAQkD,WACzFlD,EAAQuB,MAAMC,eAAe,aA8CnC,SAAyBG,GAIvB,MAAMW,EAAepF,SAASiG,cAAc,SAASxB,MACjDW,GACFA,EAAac,QAEjB,CAnDMC,CAAgB1B,GAEE,OAAdlC,GACFgB,OAAOyB,QAAQhB,EAAgBI,IAAM,CAAA,GAAIgC,SAAQ,EAAEnB,EAAKC,MACtDpC,EAAQuB,MAAMuB,YAAY9D,EAAamD,GAAMC,EAAgB,IAGjEzD,QAAQC,IAAI,cAAca,4BAAoCO,EAAQkD,WACtEvE,QAAQC,IAAI,+CAAgDoB,EAAQuB,MAAMwB,SAE1ErB,GAAS,EAGX1B,EAAQ7C,iBAAiB,eAAgB8F,EAAS,CAAEM,MAAM,GAAO,GAErE,CApGeC,CAAuBxD,EAAwBkB,EAAiBb,EAAeZ,IAEjFgC,QAAQC,SAAS,GACxB,UAGED,QAAQgC,IAAI/D,EACpB,CAgCgB,SAAAgE,EAAapE,EAA+BU,GAC1DV,EAASgE,SAAS1D,IACCI,EAAQD,iBAAiBH,EAAQI,SACzCsD,SAASK,IAChBA,EAAGpC,MAAMqC,WAAa,QAAQ,GAC9B,GAEN,CCMA,MAAMC,EAaJ,WAAAnH,CAAYC,EAAuB,UAV3BE,KAAiBiH,kBAAW,EAC5BjH,KAAUkH,WAAsB,KA2ChClH,KAAmBmH,oBAAkB,KAjC3CnH,KAAKF,QACH8D,OAAAC,OAAA,CAAAuD,YAAY,GACTtH,GAELE,KAAKyF,aAAepF,SAASqF,cAAc,SAC3C1F,KAAKyF,aAAaG,aAAa,YAAa,QAC5CvF,SAASwF,KAAKC,YAAY9F,KAAKyF,cAC/BzF,KAAKqH,eACHzD,OAAAC,OAAA,CAAAyD,SAAS,EACTC,SAAS,EACTC,QAAQ,EACRC,UAAU,GACiB,QAAvB9D,EAAA3D,KAAKF,QAAQsE,kBAAU,IAAAT,OAAA,EAAAA,EAAE+D,OAE/B1H,KAAKG,MACN,CAOO,IAAAA,GH9BM,IAAeL,EAA0BC,EG+BrDC,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,4BAEjC/B,KAAK2H,kBACL3H,KAAK4H,iBAED5H,KAAKF,QAAQkB,UAAYhB,KAAKF,QAAQkB,SAASZ,SACjDJ,KAAKkH,YHrCoBpH,EGqCQE,KAAKF,QAAQkB,SHrCKjB,EGqCKC,KAAKF,QHpC1D,IAAIF,EAAWE,EAASC,IGsC9B,CASO,eAAAgG,CAAgB1B,EAAkCzB,GACxD,MAAMU,KAAEA,EAAImB,GAAEA,GAAOJ,EACfS,EAAe,QAAQlC,OAAe5C,KAAKiH,oBAEjD,IAAI7B,EAAc,cAAcN,8BAE1BlB,OAAOyB,QAAQ/B,GAAQ,IACtBC,KAAI,EAAE+B,EAAKC,KAAW,GAAGpD,EAAamD,OAASC,OAC/CC,KAAK,sCAGN5B,OAAOyB,QAAQZ,GAAM,IACpBlB,KAAI,EAAE+B,EAAKC,KAAW,GAAGpD,EAAamD,OAASC,OAC/CC,KAAK,uBAmBZ,OAfAxF,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,qBAAuB+C,GACxD9E,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,gBAAkBqD,GAG/CpF,KAAKmH,qBACPnH,KAAKwG,gBAAgBxG,KAAKmH,qBAI5BnH,KAAKyF,aAAaE,YAAcP,EAChCpF,KAAKmH,oBAAsBrC,EAE3B9E,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,YAAc+C,EAAe,+BAC9D9E,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,4BAA8B/B,KAAKyF,aAAaE,aAE1Eb,CACR,CAOO,eAAA0B,CAAgB1B,GACtB9E,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,sBAAwB+C,GACzD9E,KAAKyF,aAAaE,YAAc,GAChC3F,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,WAAa+C,EAAe,WAC7D9E,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,yCAA2C/B,KAAKyF,aAAaE,aAC9F3F,KAAKmH,oBAAsB,IAC5B,CAOO,eAAAQ,GACN3H,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,uCAEjC1B,SAASC,iBAAiB,SAAUC,IAClC,MACMsH,EADStH,EAAMI,OACCC,QAAQ,KAC1BiH,GAAU7H,KAAK8H,gBAAgBD,KACjCtH,EAAMwH,iBACN/H,KAAKgI,YAAY,WACjBhI,KAAKiI,SAASJ,EAAO5G,MACtB,GAEJ,CAOO,eAAA6G,CAAgBD,GACtB7H,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,uCAEjC,MAAMmG,EAAa,IAAIC,IAAI/G,OAAOC,SAASJ,MACrCmH,EAAU,IAAID,IAAIN,EAAO5G,MAGzBoH,EAAeD,EAAQ9G,SAAW4G,EAAW5G,OAG7CgH,EAAaF,EAAQG,WAAaL,EAAWK,UAAYH,EAAQI,SAAWN,EAAWM,OACvFC,EAAmBH,GAAcF,EAAQM,OAASR,EAAWQ,KAGnE,OAAOL,IAAiBC,IAAeG,CACxC,CAMO,cAAAb,GACN5H,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,sCAEjCX,OAAOd,iBAAiB,YAAY,KAClCN,KAAKiI,SAAS7G,OAAOC,SAASJ,MAAM,EAAM,GAE7C,CASM,cAAMgH,CAASzG,EAAamH,GAAqB,GACtD3I,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,gCAEjC,IACE,IAAI6G,EAAyB,KACzB5I,KAAKkH,aACP0B,EAAU5I,KAAKkH,WAAWjF,WAAWT,IAGlCoH,IACHA,QAAgB5I,KAAK6I,UAAUrH,IAG7BoH,IACED,GACFG,QAAQH,UAAU,KAAM,GAAInH,GAE9BxB,KAAK+I,WAAWH,GAEnB,CAAC,MAAO5G,GACPhC,KAAKF,QAAQ+B,OAAQC,QAAQE,MAAM,qBAAsBA,EAC1D,CACF,CAMO,eAAM6G,CAAUrH,GACtBxB,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,iCAEjC,MAAMN,QAAiBC,MAAMF,GAC7B,IAAKC,EAASuH,GAAI,MAAM,IAAIC,MAAM,uBAAuBxH,EAASyH,UAClE,aAAazH,EAASE,MACvB,CAQO,gBAAMoH,CAAWH,GACvB5I,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,kCAEjC,MACMoH,GADS,IAAIC,WACGC,gBAAgBT,EAAS,mBAGzC5I,KAAKsJ,WAAWH,GAGtBnJ,KAAKoH,WAAW+B,GAGhBnJ,KAAKuJ,cAAclJ,SAAU8I,GAG7B,MAAM5I,EAAQ,IAAIiJ,YAAY,mBAC9BnJ,SAASoJ,cAAclJ,GAEvBa,OAAOsI,SAAS,EAAG,EACpB,CAOO,UAAAtC,CAAW+B,SACjBnJ,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,kCAEjC,MAAM4H,EAAUtJ,SAASwF,KACnB+D,EAAUT,EAAOtD,KAGvBxF,SAASwJ,MAAQV,EAAOU,OAEU,KAAb,QAAjBlG,EAAA3D,KAAKF,QAAQ+F,YAAI,IAAAlC,OAAA,EAAAA,EAAEmG,UAKvBzG,MAAMC,KAAKqG,EAAQI,UAAUtD,SAASuD,IAChCA,IAAUhK,KAAKyF,cAAkC,UAAlBuE,EAAM3D,SACvC2D,EAAMzD,QACP,IAIHlD,MAAMC,KAAKsG,EAAQG,UAAUtD,SAASuD,IACpC,GAAuD,UAAlBA,EAAM3D,QAAqB,CAC9D,MAAM4D,EAAWD,EAAME,WAAU,GACjCP,EAAQ7D,YAAYmE,GACpBjK,KAAKmK,iBAAiBF,EACvB,KAGHjK,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,8CAClC,CAEO,gBAAAoI,CAAiBhH,SACvB,MAAMiH,UAAEA,GAAcpK,KAAKF,QAAQ+F,MAAQ,CAAA,EAC3C,IAAKuE,EAAW,OAEhB,MAAMC,EAAmBvD,KACnBsD,EAAUE,UAAYxD,EAAGyD,QAAQH,EAAUE,QAAQpF,gBACnDkF,EAAUI,UAAW1D,EAAGyD,QAAQH,EAAUI,QAAQtF,aAIxD,GAAwB,SAApB/B,EAAQkD,SAAsB+D,EAAUK,KAAOJ,EAAgBlH,GAAU,CAC3E,MAAMzC,EAAOyC,EACbzC,EAAKO,KAAOP,EAAKO,KAAKyJ,MAAM,KAAK,GAAK,OAAQ,IAAIC,MAAOC,SAC1D,MAAM,GAAwB,WAApBzH,EAAQkD,SAAwB+D,EAAUS,IAAMR,EAAgBlH,GAAU,CACnF,MAAM2H,EAAS3H,EACT4H,EAAY1K,SAASqF,cAAc,UACzCrC,MAAMC,KAAKwH,EAAOE,YAAYvE,SAASwE,GAASF,EAAUnF,aAAaqF,EAAKC,KAAMD,EAAK1F,SACvFwF,EAAUpF,YAAcmF,EAAOnF,YACZ,QAAnBhC,EAAAmH,EAAOK,kBAAY,IAAAxH,GAAAA,EAAAyH,aAAaL,EAAWD,EAC5C,CACF,CAQO,gBAAMxB,CAAWH,SACvBnJ,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,kCAEjC,MAAMsJ,GAAkC,QAAvB1H,EAAA3D,KAAKF,QAAQsE,kBAAU,IAAAT,OAAA,EAAAA,EAAE0H,WAAY,OAChD3I,EAAarC,SAASiG,cAAc+E,GACpC1I,EAAawG,EAAO7C,cAAc+E,GAEnC3I,GAAeC,SAKd3C,KAAKsL,kBAAkB5I,EAA2BC,GAGxDD,EAAW6I,UAAY5I,EAAW4I,UAClClI,MAAMC,KAAKX,EAAWqI,YAAYvE,SAASwE,IACvB,UAAdA,EAAKC,MACPxI,EAAWkD,aAAaqF,EAAKC,KAAMD,EAAK1F,MACzC,KAXDvF,KAAKF,QAAQ+B,OAAQC,QAAQE,MAAM,sBAAsBqJ,IAa5D,CASO,aAAA9B,CAAciC,EAAkBrC,GACtC,MAAMsC,EAAyB,CAAC/I,EAAqBC,KACnD,MAAM+I,EAAarI,MAAMC,KAAKZ,EAAWQ,iBAAiB,WACpDyI,EAAatI,MAAMC,KAAKX,EAAWO,iBAAiB,WAG1DwI,EAAWjF,SAASqE,IACQa,EAAWC,MAAMb,GAAcA,EAAUc,MAAQf,EAAOe,KAAOd,EAAUpF,cAAgBmF,EAAOnF,eAExHmF,EAAOvE,QACR,IAIHoF,EAAWlF,SAASsE,YAClB,MAAMe,EAAiBJ,EAAWE,MAAMd,GAAWA,EAAOe,MAAQd,EAAUc,KAAOf,EAAOnF,aAAgBmF,EAAOnF,cAEjH,GAAImG,EAEF,GAAKf,EAAUc,IAOV,CACH,MAAME,EAAgB1L,SAASqF,cAAc,UAC7CrC,MAAMC,KAAKyH,EAAUC,YAAYvE,SAASwE,GAASc,EAAcnG,aAAaqF,EAAKC,KAAMD,EAAK1F,SACnE,QAA3BxB,EAAA+H,EAAeX,kBAAY,IAAApH,GAAAA,EAAAqH,aAAaW,EAAeD,EACxD,KAXmB,CAClB,MAAMC,EAAgB1L,SAASqF,cAAc,UAC7CrC,MAAMC,KAAKyH,EAAUC,YAAYvE,SAASwE,GAASc,EAAcnG,aAAaqF,EAAKC,KAAMD,EAAK1F,SAC9FwG,EAAcpG,YAAcoF,EAAUpF,YACX,QAA3BhC,EAAAmI,EAAeX,kBAAY,IAAAxH,GAAAA,EAAAyH,aAAaW,EAAeD,EACxD,KAOI,CAEL,MAAMC,EAAgB1L,SAASqF,cAAc,UAC7CrC,MAAMC,KAAKyH,EAAUC,YAAYvE,SAASwE,GAASc,EAAcnG,aAAaqF,EAAKC,KAAMD,EAAK1F,SAC9FwG,EAAcpG,YAAcoF,EAAUpF,YACtCjD,EAAWoD,YAAYiG,EACxB,IACD,EAIJN,EAAuBD,EAAO3F,KAAMsD,EAAOtD,MAG3C4F,EAAuBD,EAAOQ,KAAM7C,EAAO6C,KAC5C,CASO,uBAAMV,CAAkB5I,EAAyBC,GACvD3C,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,6BACjC,MAAMkK,EAAoBjM,KAAKF,QAAQsE,YAAc,CAAA,EAC/CN,EAAWmI,EAAkBnI,UAAY,IACzC5C,EAAQ+K,EAAkB/K,OAAS,EACnC+C,EAASgI,EAAkBhI,QAAU,cAE3C,IAAIiI,EAAgBD,EAAkB3H,IAClC6H,EAAeF,EAAkB1H,GAErCvE,KAAKoM,mBAAmB,WAAW,GACnCpM,KAAKgI,YAAY,WAGjB,MAAMqE,EAA0BrM,KAAKsM,6BAGrC,GAAID,EAAwBjJ,OAAS,EAAG,CACtCpD,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,oCACjC,MAAMwK,EAAqB/J,EAAe6J,EAAyBhM,SAAS2L,KAAM3L,SAAS2L,KAAMhM,KAAKF,QAAS,aAGzGyM,EAGN1F,EAAawF,EAAyBhM,SAAS2L,KAChD,CAGGE,IACFlM,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,sCAC3B/B,KAAKwM,gBAAgB9J,EAAYwJ,EAAepI,EAAU5C,EAAO+C,EAAQ,QAIjFvB,EAAW6I,UAAY5I,EAAW4I,UAClClI,MAAMC,KAAKX,EAAWqI,YAAYvE,SAASwE,IACvB,UAAdA,EAAKC,MACPxI,EAAWkD,aAAaqF,EAAKC,KAAMD,EAAK1F,MACzC,IAIC4G,IACFnM,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,qCAC3B/B,KAAKwM,gBAAgB9J,EAAYyJ,EAAcrI,EAAU5C,EAAO+C,EAAQ,OAI5EoI,EAAwBjJ,OAAS,IACnCyD,EAAawF,EAAyBhM,SAAS2L,YACzCxJ,EAAe6J,EAAyBhM,SAAS2L,KAAM3L,SAAS2L,KAAMhM,KAAKF,QAAS,OAI5FE,KAAKoM,mBAAmB,YAAY,GACpCpM,KAAKgI,YAAY,YAEjB5G,OAAOsI,SAAS,EAAG,EACpB,CAEO,0BAAA4C,WACN,MAAMjB,GAAkC,QAAvB1H,EAAA3D,KAAKF,QAAQsE,kBAAU,IAAAT,OAAA,EAAAA,EAAE0H,WAAY,OAChDoB,EAAkBpM,SAASiG,cAAc+E,GAE/C,QAA+B,QAAvBtH,EAAA/D,KAAKF,QAAQsE,kBAAU,IAAAL,OAAA,EAAAA,EAAEtB,WAAY,IAAIiK,QAAQ3J,IACvD,MAAME,EAAW5C,SAAS6C,iBAAiBH,EAAQI,SACnD,OAAOE,MAAMC,KAAKL,GAAU0J,OAAO7F,KAAQ2F,aAAe,EAAfA,EAAiBG,SAAS9F,KAAI,GAE5E,CAOO,iBAAA+F,CAAkBzI,GACxB,MAAO,CACLd,KAAMc,EAAWK,GACjBA,GAAIL,EAAWd,KAElB,CAOO,eAAAkJ,CAAgBrJ,EAAsBkB,EAAkCP,EAAkB5C,EAAe+C,EAAgBrB,GAC/H,OAAO,IAAIgC,SAASC,IAClB7E,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,YAAYa,gBAC7C,MAAMkC,EAAe9E,KAAK+F,gBAAgB1B,EAAiBzB,GACrDoD,EAAe,GAAGlB,KAAgBhB,OAAcG,KAAU/C,eAEhEiC,EAAQuB,MAAMuB,YAAY,YAAaD,GACvChG,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,WAAWa,gBAAwBoD,KACpEhG,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,yBAA0BoB,EAAQuB,MAAMwB,SAGpE/C,EAAQgD,YAoBbhD,EAAQ7C,iBAAiB,gBAlBT,KACdN,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,iCAAiCa,gBAClEO,EAAQuB,MAAMC,eAAe,aAG7B3E,KAAKwG,gBAAgB1B,GAEH,OAAdlC,GACFgB,OAAOyB,QAAQhB,EAAgBI,IAAM,CAAA,GAAIgC,SAAQ,EAAEnB,EAAKC,MACtDpC,EAAQuB,MAAMuB,YAAY9D,EAAamD,GAAMC,EAAgB,IAGjEvF,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,cAAca,eAC/C5C,KAAKF,QAAQ+B,OAAQC,QAAQC,IAAI,uCAAwCoB,EAAQuB,MAAMwB,SAEvFrB,GAAS,GAGuC,CAAE6B,MAAM,GAAO,GAEpE,CAOO,kBAAA0F,CAAmB9G,EAA2BC,GACpDvF,KAAKqH,eAAe/B,GAAOC,CAC5B,CAQO,WAAAyC,CAAY8E,WAClB,MAAMC,EAA+C,QAApChJ,EAAyB,QAAzBJ,EAAA3D,KAAKF,QAAQsE,kBAAY,IAAAT,OAAA,EAAAA,EAAAoJ,gBAAW,IAAAhJ,OAAA,EAAAA,EAAA+I,GACjDC,GAAgC,mBAAbA,GACrBA,GAEH,CAMM,eAAAC,GACLhN,KAAKoM,mBAAmB,WAAW,GACnCpM,KAAKoM,mBAAmB,WAAW,GACnCpM,KAAKoM,mBAAmB,UAAU,GAClCpM,KAAKoM,mBAAmB,YAAY,GACpCpM,KAAKgI,YAAY,WACjBhI,KAAKgI,YAAY,SAClB,CAMM,eAAAiF,SACL,GAAIjN,KAAKqH,eAAeE,QAAS,CAC/BvH,KAAKoM,mBAAmB,WAAW,GACnCpM,KAAKoM,mBAAmB,UAAU,GAClCpM,KAAKgI,YAAY,WAGjB,MAAM7E,EAAU9C,SAASiG,eAAqC,QAAvB3C,EAAA3D,KAAKF,QAAQsE,kBAAU,IAAAT,OAAA,EAAAA,EAAE0H,WAAY,QACxElI,aAAmB+J,cACrB/J,EAAQuB,MAAMyI,mBAAqB,SAEtC,CACF,CAMM,gBAAAC,SACL,GAAIpN,KAAKqH,eAAeG,OAAQ,CAC9BxH,KAAKoM,mBAAmB,WAAW,GACnCpM,KAAKoM,mBAAmB,UAAU,GAClCpM,KAAKgI,YAAY,UAGjB,MAAM7E,EAAU9C,SAASiG,eAAqC,QAAvB3C,EAAA3D,KAAKF,QAAQsE,kBAAU,IAAAT,OAAA,EAAAA,EAAE0H,WAAY,QACxElI,aAAmB+J,cACrB/J,EAAQuB,MAAMyI,mBAAqB,UAEtC,CACF,CAMM,gBAAAE,GACLrN,KAAKoM,mBAAmB,WAAW,GACnCpM,KAAKoM,mBAAmB,UAAU,GAClCpM,KAAKoM,mBAAmB,YAAY,GACpCpM,KAAKgI,YAAY,WAClB,SAQH,SAAclI,EAAuB,IACnC,OAAO,IAAIkH,EAAKlH,EAClB"}