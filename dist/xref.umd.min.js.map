{"version":3,"file":"xref.umd.min.js","sources":["../src/prefetch.ts","../src/utils.ts","../src/partials.ts","../src/xref.ts"],"sourcesContent":["import { XrefOptions } from \"./xref\";\n\ninterface PrefetchOptions {\n  event?: string;\n  delay?: number;\n  selector?: string;\n  active?: boolean;\n}\n\nexport class Prefetcher {\n  private cache: Map<string, string> = new Map();\n  private options: PrefetchOptions;\n  private xrefOptions: XrefOptions;\n\n  /**\n   *\n   * @description Initializes the prefetcher\n   * with the given options.\n   */\n  constructor(options: PrefetchOptions, xrefOptions: XrefOptions) {\n    this.options = options;\n    this.xrefOptions = xrefOptions;\n    this.init();\n  }\n\n  /**\n   * @description Initializes the prefetcher by\n   * adding an event listener to the document.\n   */\n  private init() {\n    if (!this.options.active) return;\n    document.addEventListener(this.options.event || \"mouseover\", this.handleEvent.bind(this));\n  }\n\n  /**\n   *\n   * @description Handles the event by checking if the target\n   * is an anchor element and if it should be prefetched.\n   */\n  private handleEvent(event: Event) {\n    const target = event.target as HTMLElement;\n    const link = target.closest(this.options.selector || \"a\") as HTMLAnchorElement | null;\n\n    if (link && this.shouldPrefetch(link)) {\n      setTimeout(() => this.prefetch(link.href), this.options.delay || 100);\n    }\n  }\n\n  /**\n   *\n   * @description Checks if the link should be prefetched.\n   * It should be prefetched if it's an anchor element, it's\n   * not the current page, and it's not already in the cache.\n   */\n  private shouldPrefetch(link: HTMLAnchorElement): boolean {\n    return !!(link.href && link.href.startsWith(window.location.origin) && link.href !== window.location.href && !this.cache.has(link.href));\n  }\n\n  /**\n   *\n   * @description Fetches the content of the given URL\n   * and stores it in the cache. If the fetch fails, it logs\n   * an error to the console.\n   */\n  private async prefetch(url: string) {\n    try {\n      const response = await fetch(url);\n      const text = await response.text();\n      this.cache.set(url, text);\n      this.xrefOptions.debug ? console.log(`Prefetched: ${url}`) : null;\n    } catch (error) {\n      this.xrefOptions.debug ? console.error(\"Failed to prefetch:\" + url, error) : null;\n    }\n  }\n\n  /**\n   *\n   * @description Gets the content of the given URL\n   * from the cache. If the content is not in the cache,\n   * it returns null. Otherwise, it returns the content.\n   * This method is used by the Xref instance to get the\n   * content of a URL before navigating to it.\n   */\n  public getContent(url: string): string | null {\n    return this.cache.get(url) || null;\n  }\n}\n\nexport function initPrefetcher(options: PrefetchOptions, xrefOptions: XrefOptions): Prefetcher {\n  return new Prefetcher(options, xrefOptions);\n}\n","/**\n *\n * @description Convert camelCase to kebab-case\n */\nexport function camelToKebab(str: string): string {\n  return str.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n","import { XrefOptions, TransitionOptions, TransitionState, PartialTransition } from \"./xref\";\nimport { camelToKebab } from \"./utils\";\n\nexport async function handlePartials(partials: PartialTransition[], oldElement: HTMLElement, newElement: HTMLElement, options: XrefOptions, direction: \"in\" | \"out\") {\n  options.debug ? console.log(`Handling partials for ${direction} transition`) : null;\n\n  const partialPromises = partials.flatMap((partial) => {\n    const elements = oldElement.querySelectorAll(partial.element);\n    options.debug ? console.log(`Found ${elements.length} elements matching selector: ${partial.element}`) : null;\n\n    return Array.from(elements).map((element) => {\n      if (direction === \"out\" && partial.out) {\n        return applyPartialTransition(element as HTMLElement, partial.out, options, \"out\");\n      } else if (direction === \"in\" && partial.in) {\n        return applyPartialTransition(element as HTMLElement, partial.in, options, \"in\");\n      }\n      return Promise.resolve();\n    });\n  });\n\n  await Promise.all(partialPromises);\n}\n\nexport function hidePartials(partials: PartialTransition[], element: HTMLElement) {\n  partials.forEach((partial) => {\n    const elements = element.querySelectorAll(partial.element);\n    elements.forEach((el: HTMLElement | any) => {\n      el.style.visibility = \"hidden\";\n    });\n  });\n}\n\nexport function showPartials(partials: PartialTransition[], element: HTMLElement) {\n  partials.forEach((partial) => {\n    const elements = element.querySelectorAll(partial.element);\n    elements.forEach((el: HTMLElement | any) => {\n      el.style.visibility = \"visible\";\n    });\n  });\n}\n\nasync function applyPartialTransition(element: HTMLElement, transitionState: TransitionState, options: XrefOptions, direction: \"in\" | \"out\"): Promise<void> {\n  return new Promise((resolve) => {\n    const transitionOptions = options.transition as TransitionOptions;\n    const duration = transitionOptions.duration || 300;\n    const delay = transitionOptions.delay || 0;\n    const easing = transitionOptions.easing || \"ease-in-out\";\n\n    options.debug ? console.log(`Applying ${direction} transition to partial: ${element.tagName}`) : null;\n    const keyframeName = createKeyframes(transitionState, direction);\n    const animationCSS = `${keyframeName} ${duration / 2}ms ${easing} ${delay}ms forwards`;\n\n    element.style.setProperty(\"animation\", animationCSS);\n    options.debug ? console.log(`Applied ${direction} animation to partial: ${animationCSS}`) : null;\n    options.debug ? console.log(\"Current partial element style:\", element.style.cssText) : null;\n\n    // Force a reflow to ensure the animation is applied immediately\n    void element.offsetWidth;\n\n    const cleanup = () => {\n      options.debug ? console.log(`Animation end event fired for ${direction} transition on partial: ${element.tagName}`) : null;\n      element.style.removeProperty(\"animation\");\n\n      // Remove the keyframe immediately after the animation is complete\n      removeKeyframes(keyframeName);\n\n      if (direction === \"in\") {\n        Object.entries(transitionState.to || {}).forEach(([key, value]) => {\n          element.style.setProperty(camelToKebab(key), value as string);\n        });\n      }\n      options.debug ? console.log(`Cleaned up ${direction} animation for partial: ${element.tagName}`) : null;\n      options.debug ? console.log(\"Current partial element style after cleanup:\", element.style.cssText) : null;\n\n      resolve();\n    };\n\n    element.addEventListener(\"animationend\", cleanup, { once: true });\n  });\n}\n\nfunction createKeyframes(transitionState: TransitionState, direction: \"in\" | \"out\"): string {\n  const { from, to } = transitionState;\n  const keyframeName = `xref-partial-${direction}-${Math.random().toString(36).substr(2, 9)}`;\n\n  const keyframeCSS = `@keyframes ${keyframeName} {\n    from {\n      ${Object.entries(from || {})\n        .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n        .join(\" \")}\n    }\n    to {\n      ${Object.entries(to || {})\n        .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n        .join(\" \")}\n    }\n  }`;\n\n  const styleElement = document.createElement(\"style\");\n  styleElement.textContent = keyframeCSS;\n  document.head.appendChild(styleElement);\n\n  return keyframeName;\n}\n\nfunction removeKeyframes(keyframeName: string) {\n  const styleElement = document.querySelector(`style:not([data-xref=\"true\"]):last-of-type`);\n  if (styleElement) {\n    styleElement.remove();\n  }\n}","import { Prefetcher, initPrefetcher } from \"./prefetch\";\nimport { handlePartials, hidePartials, showPartials } from \"./partials\";\nimport { camelToKebab } from \"./utils\";\n\nexport interface XrefOptions {\n  debug?: boolean;\n  updateHead?: boolean;\n  transition?: TransitionOptions;\n  prefetch?: PrefetchOptions;\n  head?: HeadOptions;\n}\n\nexport interface HeadOptions {\n  update?: boolean;\n  retrigger?: {\n    css?: boolean;\n    js?: boolean;\n    include?: string | RegExp;\n    exclude?: string | RegExp;\n  };\n}\nexport interface PrefetchOptions {\n  active: boolean;\n  delay: number;\n  event: string;\n  selector?: string;\n}\n\nexport interface TransitionOptions {\n  duration?: number;\n  delay?: number;\n  easing?: string;\n  timeline?: \"sequential\" | \"parallel\";\n  in?: TransitionState;\n  out?: TransitionState;\n  callback?: TransitionCallbacks;\n  state?: AnimationState;\n  swapHtml?: string;\n  partials?: PartialTransition[];\n}\n\nexport interface PartialTransition {\n  element: string;\n  duration?: number;\n  delay?: number;\n  easing?: string;\n  in?: TransitionState;\n  out?: TransitionState;\n}\n\nexport interface TransitionState {\n  from?: Record<string, string | number>;\n  to?: Record<string, string | number>;\n}\n\nexport interface AnimationState {\n  started: boolean;\n  playing: boolean;\n  paused: boolean;\n  finished: boolean;\n}\n\nexport interface TransitionCallbacks {\n  onEnter?: () => void;\n  onStart?: () => void;\n  onPlay?: () => void;\n  onPause?: () => void;\n  onFinish?: () => void;\n}\n\n/**\n * The main Xref class that handles\n * navigation and transitions.\n *\n * @returns The Xref instance.\n *\n * @description This is the main class that handles navigation and transitions.\n * It intercepts clicks on internal links, fetches the content of the linked page,\n * updates the document head and body, and performs transitions between the\n * old and new content. It also handles popstate events to support back\n * and forward navigation.\n */\nclass Xref {\n  private options: XrefOptions;\n  private styleElement: HTMLStyleElement;\n  private transitionCounter: number = 0;\n  private prefetcher: Prefetcher | null = null;\n  private animationState: AnimationState;\n\n  /**\n   * @description This is the constructor of the Xref class.\n   * It initializes the Xref instance with the given options,\n   * creates a style element to store the keyframes for transitions,\n   * and sets the initial animation state.\n   */\n  constructor(options: XrefOptions = {}) {\n    this.options = {\n      updateHead: true,\n      ...options,\n    };\n    this.styleElement = document.createElement(\"style\");\n    this.styleElement.setAttribute(\"data-xref\", \"true\");\n    document.head.appendChild(this.styleElement);\n    this.animationState = {\n      started: false,\n      playing: true,\n      paused: false,\n      finished: false,\n      ...(this.options.transition?.state as Partial<AnimationState>),\n    };\n    this.init();\n  }\n\n  /**\n   * @description This method initializes the Xref instance\n   * by intercepting clicks on internal links, handling popstate events,\n   * and initializing the prefetcher if prefetching is enabled.\n   */\n  private init() {\n    this.options.debug ? console.log(\"started -> init() Method\") : null;\n\n    this.interceptClicks();\n    this.handlePopState();\n\n    if (this.options.prefetch && this.options.prefetch.active) {\n      this.prefetcher = initPrefetcher(this.options.prefetch, this.options);\n    }\n  }\n\n  private currentKeyframeName: string | null = null;\n\n  /**\n   * @description This method creates keyframes\n   * for the given transition state\n   * and direction.\n   */\n  private createKeyframes(transitionState: TransitionState, direction: \"in\" | \"out\"): string {\n    const { from, to } = transitionState;\n    const keyframeName = `xref-${direction}-${++this.transitionCounter}`;\n\n    let keyframeCSS = `@keyframes ${keyframeName} {\n      from {\n        ${Object.entries(from || {})\n          .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n      to {\n        ${Object.entries(to || {})\n          .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n    }`;\n\n    this.options.debug ? console.log(\"Creating keyframe:\" + keyframeName) : null;\n    this.options.debug ? console.log(\"Keyframe CSS:\" + keyframeCSS) : null;\n\n    // Remove the previous keyframe if it exists\n    if (this.currentKeyframeName) {\n      this.removeKeyframes(this.currentKeyframeName);\n    }\n\n    // Append the new keyframe to the style element's content\n    this.styleElement.textContent = keyframeCSS;\n    this.currentKeyframeName = keyframeName;\n\n    this.options.debug ? console.log(\"Keyframe \" + keyframeName + \"appended to <style> element\") : null;\n    this.options.debug ? console.log(\"Current <style> content: \" + this.styleElement.textContent) : null;\n\n    return keyframeName;\n  }\n\n  /**\n   * @param keyframeName\n   * @description This method removes the keyframes\n   * with the given name from the style element.\n   */\n  private removeKeyframes(keyframeName: string) {\n    this.options.debug ? console.log(\"Removing keyframe: \" + keyframeName) : null;\n    this.styleElement.textContent = \"\";\n    this.options.debug ? console.log(\"Keyframe\" + keyframeName + \"removed\") : null;\n    this.options.debug ? console.log(\"Current <style> content after removal:\" + this.styleElement.textContent) : null;\n    this.currentKeyframeName = null;\n  }\n\n  /**\n   * @description This method intercepts clicks\n   * on internal links and prevents the default\n   * browser navigation behavior.\n   */\n  private interceptClicks() {\n    this.options.debug ? console.log(\"started -> interceptClicks() Method\") : null;\n\n    document.addEventListener(\"click\", (event) => {\n      const target = event.target as HTMLElement;\n      const anchor = target.closest(\"a\");\n      if (anchor && this.shouldIntercept(anchor as HTMLAnchorElement)) {\n        event.preventDefault();\n        this.runCallback(\"onEnter\");\n        this.navigate(anchor.href);\n      }\n    });\n  }\n\n  /**\n   * @description This method checks if the\n   * anchor should be intercepted based on\n   * the current URL and the anchor's href.\n   */\n  private shouldIntercept(anchor: HTMLAnchorElement): boolean {\n    this.options.debug ? console.log(\"started -> shouldIntercept() Method\") : null;\n\n    const currentUrl = new URL(window.location.href);\n    const linkUrl = new URL(anchor.href);\n\n    // Check if it's an internal link\n    const isSameOrigin = linkUrl.origin === currentUrl.origin;\n\n    // Check if it's not the current page or just a hash change\n    const isSamePage = linkUrl.pathname === currentUrl.pathname && linkUrl.search === currentUrl.search;\n    const isJustHashChange = isSamePage && linkUrl.hash !== currentUrl.hash;\n\n    // Intercept only if it's an internal link and not the same page or just a hash change\n    return isSameOrigin && !isSamePage && !isJustHashChange;\n  }\n\n  /**\n   * @description This method handles popstate events\n   * to support back and forward navigation.\n   */\n  private handlePopState() {\n    this.options.debug ? console.log(\"started -> handlePopState() Method\") : null;\n\n    window.addEventListener(\"popstate\", () => {\n      this.navigate(window.location.href, false);\n    });\n  }\n\n  /**\n   * @description This method navigates to the given URL\n   * and updates the page content. If prefetching is enabled\n   * and the content is already prefetched, it uses the\n   * prefetched content instead of fetching it again.\n   * If pushState is true, it updates the browser history.\n   */\n  public async navigate(url: string, pushState: boolean = true) {\n    this.options.debug ? console.log(\"started -> navigate() Method\") : null;\n\n    try {\n      let content: string | null = null;\n      if (this.prefetcher) {\n        content = this.prefetcher.getContent(url);\n      }\n\n      if (!content) {\n        content = await this.fetchPage(url);\n      }\n\n      if (content) {\n        if (pushState) {\n          history.pushState(null, \"\", url);\n        }\n        this.updatePage(content);\n      }\n    } catch (error) {\n      this.options.debug ? console.error(\"Navigation failed:\", error) : null;\n    }\n  }\n\n  /**\n   * @description This method fetches the content of the given URL\n   * and returns it as a string. It throws an error if the request fails.\n   */\n  private async fetchPage(url: string): Promise<string> {\n    this.options.debug ? console.log(\"started -> fetchPage() Method\") : null;\n\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    return await response.text();\n  }\n\n  /**\n   * @description This method updates the page content\n   * with the new content fetched from the server.\n   * It updates the head and body of the document\n   * based on the new content.\n   */\n  private async updatePage(content: string) {\n    this.options.debug ? console.log(\"started -> updatePage() Method\") : null;\n\n    const parser = new DOMParser();\n    const newDoc = parser.parseFromString(content, \"text/html\");\n\n    await this.updateBody(newDoc);\n    this.updateHead(newDoc);\n  }\n\n  /**\n   * @description This method updates the head of the document\n   * with the new head from the fetched content. It updates\n   * the title and other head elements based on the new content.\n   */\n  private updateHead(newDoc: Document) {\n    this.options.debug ? console.log(\"started -> updateHead() Method\") : null;\n\n    const oldHead = document.head;\n    const newHead = newDoc.head;\n\n    // Always update the title\n    document.title = newDoc.title;\n\n    if (this.options.head?.update === false) {\n      return;\n    }\n\n    // Remove old elements except our style element and title\n    Array.from(oldHead.children).forEach((child) => {\n      if (child !== this.styleElement && child.tagName !== \"TITLE\") {\n        child.remove();\n      }\n    });\n\n    // Add new elements\n    Array.from(newHead.children).forEach((child) => {\n      if (child.tagName !== \"STYLE\" && child.tagName !== \"TITLE\") {\n        const newChild = child.cloneNode(true) as HTMLElement;\n        oldHead.appendChild(newChild);\n        this.retriggerElement(newChild);\n      }\n    });\n\n    this.options.debug ? console.log(\"Head updated, xref style element preserved\") : null;\n  }\n\n  private retriggerElement(element: HTMLElement) {\n    const { retrigger } = this.options.head || {};\n    if (!retrigger) return;\n\n    const shouldRetrigger = (el: HTMLElement): boolean => {\n      if (retrigger.include && !el.matches(retrigger.include.toString())) return false;\n      if (retrigger.exclude && el.matches(retrigger.exclude.toString())) return false;\n      return true;\n    };\n\n    if (element.tagName === \"LINK\" && retrigger.css && shouldRetrigger(element)) {\n      const link = element as HTMLLinkElement;\n      link.href = link.href.split(\"?\")[0] + \"?t=\" + new Date().getTime();\n    } else if (element.tagName === \"SCRIPT\" && retrigger.js && shouldRetrigger(element)) {\n      const script = element as HTMLScriptElement;\n      const newScript = document.createElement(\"script\");\n      Array.from(script.attributes).forEach((attr) => newScript.setAttribute(attr.name, attr.value));\n      newScript.textContent = script.textContent;\n      script.parentNode?.replaceChild(newScript, script);\n    }\n  }\n\n  /**\n   * @description This method updates the body of the document\n   * with the new body from the fetched content. It updates\n   * the content of the swapHtml element based on the new content.\n   * It also performs the transition between the old and new content.\n   */\n  private async updateBody(newDoc: Document) {\n    this.options.debug ? console.log(\"started -> updateBody() Method\") : null;\n\n    const swapHtml = this.options.transition?.swapHtml || \"body\";\n    const oldElement = document.querySelector(swapHtml);\n    const newElement = newDoc.querySelector(swapHtml);\n\n    if (!oldElement || !newElement) {\n      this.options.debug ? console.error(`Element not found: ${swapHtml}`) : null;\n      return;\n    }\n\n    await this.performTransition(oldElement as HTMLElement, newElement as HTMLElement);\n\n    window.scrollTo(0, 0);\n  }\n\n  /**\n   * @description This method performs the transition\n   * between the old and new content by applying the\n   * in and out transitions to the elements.\n   * It also handles the transition timeline, duration,\n   * delay, and easing.\n   */\n  private async performTransition(oldElement: HTMLElement, newElement: HTMLElement) {\n    this.options.debug ? console.log(\"Started performTransition\") : null;\n    const transitionOptions = this.options.transition || {};\n    const duration = transitionOptions.duration || 300;\n    const delay = transitionOptions.delay || 0;\n    const easing = transitionOptions.easing || \"ease-in-out\";\n\n    let outTransition = transitionOptions.out;\n    let inTransition = transitionOptions.in;\n\n    this.setTransitionState(\"started\", true);\n    this.runCallback(\"onStart\");\n\n    // Get partials outside swapHtml\n    const partialsOutsideSwapHtml = this.getPartialsOutsideSwapHtml();\n\n    // 1. Apply all out partial animations in parallel (outside swapHtml)\n    if (partialsOutsideSwapHtml.length > 0) {\n      this.options.debug ? console.log(\"Applying partial out transitions\") : null;\n      await handlePartials(partialsOutsideSwapHtml, document.body, document.body, this.options, \"out\");\n    }\n\n    // Hide partials before main out transition\n    if (partialsOutsideSwapHtml.length > 0) {\n      hidePartials(partialsOutsideSwapHtml, document.body);\n    }\n\n    // 2. Apply main out transition\n    if (outTransition) {\n      this.options.debug ? console.log(\"Applying main out transition\") : null;\n      await this.applyTransition(oldElement, outTransition, duration / 2, delay, easing, \"out\");\n    }\n\n    // Update content of swapHtml\n    oldElement.innerHTML = newElement.innerHTML;\n    Array.from(newElement.attributes).forEach((attr) => {\n      if (attr.name !== \"style\") {\n        oldElement.setAttribute(attr.name, attr.value);\n      }\n    });\n\n    // 3. Apply main in transition\n    if (inTransition) {\n      this.options.debug ? console.log(\"Applying main in transition\") : null;\n      await this.applyTransition(oldElement, inTransition, duration / 2, 0, easing, \"in\");\n    }\n\n    // Show partials before applying in transitions\n    if (partialsOutsideSwapHtml.length > 0) {\n      showPartials(partialsOutsideSwapHtml, document.body);\n    }\n\n    // 4. Apply all in partial animations in parallel (outside swapHtml)\n    if (partialsOutsideSwapHtml.length > 0) {\n      this.options.debug ? console.log(\"Applying partial in transitions\") : null;\n      await handlePartials(partialsOutsideSwapHtml, document.body, document.body, this.options, \"in\");\n    }\n\n    this.setTransitionState(\"finished\", true);\n    this.runCallback(\"onFinish\");\n\n    window.scrollTo(0, 0);\n  }\n\n  private getPartialsOutsideSwapHtml(): PartialTransition[] {\n    const swapHtml = this.options.transition?.swapHtml || \"body\";\n    const swapHtmlElement = document.querySelector(swapHtml);\n\n    return (this.options.transition?.partials || []).filter((partial) => {\n      const elements = document.querySelectorAll(partial.element);\n      return Array.from(elements).every((el) => !swapHtmlElement?.contains(el));\n    });\n  }\n\n  /**\n   * @description This method reverses the given transition\n   * by swapping the from and to states. This is useful\n   * for creating the \"out\" transition from the \"in\" transition.\n   */\n  private reverseTransition(transition: TransitionState): TransitionState {\n    return {\n      from: transition.to,\n      to: transition.from,\n    };\n  }\n\n  /**\n   * @description This method applies the transition to the element\n   * by creating the keyframes, setting the animation properties,\n   * and cleaning up after the animation is complete.\n   */\n  private applyTransition(element: HTMLElement, transitionState: TransitionState, duration: number, delay: number, easing: string, direction: \"in\" | \"out\"): Promise<void> {\n    return new Promise((resolve) => {\n      this.options.debug ? console.log(`Applying ${direction} transition`) : null;\n      const keyframeName = this.createKeyframes(transitionState, direction);\n      const animationCSS = `${keyframeName} ${duration}ms ${easing} ${delay}ms forwards`;\n\n      element.style.setProperty(\"animation\", animationCSS);\n      this.options.debug ? console.log(`Applied ${direction} animation: ${animationCSS}`) : null;\n      this.options.debug ? console.log(\"Current element style:\", element.style.cssText) : null;\n\n      // Force a reflow to ensure the animation is applied immediately\n      void element.offsetWidth;\n\n      const cleanup = () => {\n        this.options.debug ? console.log(`Animation end event fired for ${direction} transition`) : null;\n        element.style.removeProperty(\"animation\");\n\n        // Remove the keyframe immediately after the animation is complete\n        this.removeKeyframes(keyframeName);\n\n        if (direction === \"in\") {\n          Object.entries(transitionState.to || {}).forEach(([key, value]) => {\n            element.style.setProperty(camelToKebab(key), value as string);\n          });\n        }\n        this.options.debug ? console.log(`Cleaned up ${direction} animation`) : null;\n        this.options.debug ? console.log(\"Current element style after cleanup:\", element.style.cssText) : null;\n\n        resolve();\n      };\n\n      element.addEventListener(\"animationend\", cleanup, { once: true });\n    });\n  }\n\n  /**\n   * @description This method sets the transition state\n   * based on the given key and value. This is useful\n   * for tracking the state of the transition.\n   */\n  private setTransitionState(key: keyof AnimationState, value: boolean) {\n    this.animationState[key] = value;\n  }\n\n  private runCallback(callbackName: keyof TransitionCallbacks) {\n    const callback = this.options.transition?.callback?.[callbackName];\n    if (callback && typeof callback === \"function\") {\n      callback();\n    }\n  }\n\n  /**\n   * @description This method starts the transition\n   * and sets the animation state accordingly.\n   */\n  public startTransition() {\n    this.setTransitionState(\"started\", true);\n    this.setTransitionState(\"playing\", true);\n    this.setTransitionState(\"paused\", false);\n    this.setTransitionState(\"finished\", false);\n    this.runCallback(\"onStart\");\n    this.runCallback(\"onPlay\");\n  }\n\n  /**\n   * @description This method pauses the transition\n   * and sets the animation state accordingly.\n   */\n  public pauseTransition() {\n    if (this.animationState.playing) {\n      this.setTransitionState(\"playing\", false);\n      this.setTransitionState(\"paused\", true);\n      this.runCallback(\"onPause\");\n\n      // Pause transition\n      const element = document.querySelector(this.options.transition?.swapHtml || \"body\");\n      if (element instanceof HTMLElement) {\n        element.style.animationPlayState = \"paused\";\n      }\n    }\n  }\n\n  /**\n   * @description This method resumes the transition\n   * and sets the animation state accordingly.\n   */\n  public resumeTransition() {\n    if (this.animationState.paused) {\n      this.setTransitionState(\"playing\", true);\n      this.setTransitionState(\"paused\", false);\n      this.runCallback(\"onPlay\");\n\n      // Play transition\n      const element = document.querySelector(this.options.transition?.swapHtml || \"body\");\n      if (element instanceof HTMLElement) {\n        element.style.animationPlayState = \"running\";\n      }\n    }\n  }\n\n  /**\n   * @description This method finishes the transition\n   * and cleans up the animation\n   * */\n  public finishTransition() {\n    this.setTransitionState(\"playing\", false);\n    this.setTransitionState(\"paused\", false);\n    this.setTransitionState(\"finished\", true);\n    this.runCallback(\"onFinish\");\n  }\n\n}\n\nfunction xref(options: XrefOptions = {}): Xref {\n  return new Xref(options);\n}\n\nexport default xref;"],"names":["Prefetcher","constructor","options","xrefOptions","this","cache","Map","init","active","document","addEventListener","event","handleEvent","bind","link","target","closest","selector","shouldPrefetch","setTimeout","prefetch","href","delay","startsWith","window","location","origin","has","url","response","fetch","text","set","debug","console","log","error","getContent","get","camelToKebab","str","replace","toLowerCase","async","handlePartials","partials","oldElement","newElement","direction","partialPromises","flatMap","partial","elements","querySelectorAll","element","length","Array","from","map","out","applyPartialTransition","in","Promise","resolve","all","transitionState","transitionOptions","transition","duration","easing","tagName","keyframeName","to","Math","random","toString","substr","keyframeCSS","Object","entries","key","value","join","styleElement","createElement","textContent","head","appendChild","createKeyframes","animationCSS","style","setProperty","cssText","offsetWidth","removeProperty","querySelector","remove","removeKeyframes","forEach","once","Xref","transitionCounter","prefetcher","currentKeyframeName","assign","updateHead","setAttribute","animationState","started","playing","paused","finished","_a","state","interceptClicks","handlePopState","anchor","shouldIntercept","preventDefault","runCallback","navigate","currentUrl","URL","linkUrl","isSameOrigin","isSamePage","pathname","search","isJustHashChange","hash","pushState","content","fetchPage","history","updatePage","ok","Error","status","newDoc","DOMParser","parseFromString","updateBody","oldHead","newHead","title","update","children","child","newChild","cloneNode","retriggerElement","retrigger","shouldRetrigger","el","include","matches","exclude","css","split","Date","getTime","js","script","newScript","attributes","attr","name","parentNode","replaceChild","swapHtml","performTransition","scrollTo","outTransition","inTransition","setTransitionState","partialsOutsideSwapHtml","getPartialsOutsideSwapHtml","body","visibility","applyTransition","innerHTML","showPartials","swapHtmlElement","_b","filter","every","contains","reverseTransition","callbackName","callback","startTransition","pauseTransition","HTMLElement","animationPlayState","resumeTransition","finishTransition"],"mappings":"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"}