{"version":3,"file":"xref.umd.min.js","sources":["../src/prefetch.ts","../src/utils.ts","../src/partials.ts","../src/xref.ts"],"sourcesContent":["import { XrefOptions } from \"./xref\";\n\ninterface PrefetchOptions {\n  event?: string;\n  delay?: number;\n  selector?: string;\n  active?: boolean;\n}\n\nexport class Prefetcher {\n  private cache: Map<string, string> = new Map();\n  private options: PrefetchOptions;\n  private xrefOptions: XrefOptions;\n\n  /**\n   *\n   * @description Initializes the prefetcher\n   * with the given options.\n   */\n  constructor(options: PrefetchOptions, xrefOptions: XrefOptions) {\n    this.options = options;\n    this.xrefOptions = xrefOptions;\n    this.init();\n  }\n\n  /**\n   * @description Initializes the prefetcher by\n   * adding an event listener to the document.\n   */\n  private init() {\n    if (!this.options.active) return;\n    document.addEventListener(this.options.event || \"mouseover\", this.handleEvent.bind(this));\n  }\n\n  /**\n   *\n   * @description Handles the event by checking if the target\n   * is an anchor element and if it should be prefetched.\n   */\n  private handleEvent(event: Event) {\n    const target = event.target as HTMLElement;\n    const link = target.closest(this.options.selector || \"a\") as HTMLAnchorElement | null;\n\n    if (link && this.shouldPrefetch(link)) {\n      setTimeout(() => this.prefetch(link.href), this.options.delay || 100);\n    }\n  }\n\n  /**\n   *\n   * @description Checks if the link should be prefetched.\n   * It should be prefetched if it's an anchor element, it's\n   * not the current page, and it's not already in the cache.\n   */\n  private shouldPrefetch(link: HTMLAnchorElement): boolean {\n    return !!(link.href && link.href.startsWith(window.location.origin) && link.href !== window.location.href && !this.cache.has(link.href));\n  }\n\n  /**\n   *\n   * @description Fetches the content of the given URL\n   * and stores it in the cache. If the fetch fails, it logs\n   * an error to the console.\n   */\n  private async prefetch(url: string) {\n    try {\n      const response = await fetch(url);\n      const text = await response.text();\n      this.cache.set(url, text);\n      this.xrefOptions.debug ? console.log(`Prefetched: ${url}`) : null;\n    } catch (error) {\n      this.xrefOptions.debug ? console.error(\"Failed to prefetch:\" + url, error) : null;\n    }\n  }\n\n  /**\n   *\n   * @description Gets the content of the given URL\n   * from the cache. If the content is not in the cache,\n   * it returns null. Otherwise, it returns the content.\n   * This method is used by the Xref instance to get the\n   * content of a URL before navigating to it.\n   */\n  public getContent(url: string): string | null {\n    return this.cache.get(url) || null;\n  }\n}\n\nexport function initPrefetcher(options: PrefetchOptions, xrefOptions: XrefOptions): Prefetcher {\n  return new Prefetcher(options, xrefOptions);\n}\n","/**\n *\n * @description Convert camelCase to kebab-case\n */\nexport function camelToKebab(str: string): string {\n  return str.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n","import { XrefOptions, TransitionOptions, TransitionState, PartialTransition } from \"./xref\";\nimport { camelToKebab } from \"./utils\";\n\nexport async function handlePartials(partials: PartialTransition[], oldElement: HTMLElement, newElement: HTMLElement, options: XrefOptions, direction: \"in\" | \"out\") {\n  options.debug ? console.log(`Handling partials for ${direction} transition`) : null;\n\n  const partialPromises = partials.flatMap((partial, index) => {\n    const elements = oldElement.querySelectorAll(partial.element);\n    options.debug ? console.log(`Found ${elements.length} elements matching selector: ${partial.element}`) : null;\n\n    return Array.from(elements).map((element) => {\n      const mergedOptions = mergeOptions(partial, options.transition, index);\n\n      if (direction === \"out\" && partial.out) {\n        return applyPartialTransition(element as HTMLElement, partial.out, mergedOptions, \"out\");\n      } else if (direction === \"in\" && partial.in) {\n        // remove visibility:;hidden in inline styles\n        element.style.removeProperty(\"visibility\");\n\n        return applyPartialTransition(element as HTMLElement, partial.in, mergedOptions, \"in\");\n      }\n      return Promise.resolve();\n    });\n  });\n\n  await Promise.all(partialPromises);\n}\n\nfunction mergeOptions(partial: PartialTransition, globalTransition: TransitionOptions | undefined, index: number): TransitionOptions {\n  const globalPartial = globalTransition?.partials?.[index] || {};\n  return {\n    ...globalTransition,\n    ...globalPartial,\n    duration: partial.duration ?? globalTransition?.duration,\n    delay: partial.delay ?? globalTransition?.delay,\n    easing: partial.easing ?? globalTransition?.easing,\n  };\n}\n\nexport function hidePartials(partials: PartialTransition[], element: HTMLElement) {\n  partials.forEach((partial) => {\n    const elements = element.querySelectorAll(partial.element);\n    elements.forEach((el: HTMLElement | any) => {\n      el.style.visibility = \"hidden\";\n    });\n  });\n}\n\nexport function showPartials(partials: PartialTransition[], element: HTMLElement) {\n  partials.forEach((partial) => {\n    const elements = element.querySelectorAll(partial.element);\n    elements.forEach((el: HTMLElement | any) => {\n      el.style.visibility = \"visible\";\n    });\n  });\n}\n\nasync function applyPartialTransition(element: HTMLElement, transitionState: TransitionState, options: TransitionOptions, direction: \"in\" | \"out\"): Promise<void> {\n  return new Promise((resolve) => {\n    \n    const duration = options.duration || 300;\n    const delay = options.delay ?? 0;\n    const easing = options.easing || \"ease-in-out\";\n\n    const keyframeName = createKeyframes(transitionState, direction);\n    const animationCSS = `${keyframeName} ${duration}ms ${easing} ${delay}ms forwards`;\n\n    element.style.setProperty(\"animation\", animationCSS);\n    console.log(`Applied ${direction} animation to partial: ${animationCSS}`);\n    console.log(\"Current partial element style:\", element.style.cssText);\n\n    // Force a reflow to ensure the animation is applied immediately\n    void element.offsetWidth;\n\n    const cleanup = () => {\n      console.log(`Animation end event fired for ${direction} transition on partial: ${element.tagName}`);\n      element.style.removeProperty(\"animation\");\n\n      // Remove the keyframe immediately after the animation is complete\n      removeKeyframes(keyframeName);\n\n      if (direction === \"in\") {\n        Object.entries(transitionState.to || {}).forEach(([key, value]) => {\n          element.style.setProperty(camelToKebab(key), value as string);\n        });\n      }\n      console.log(`Cleaned up ${direction} animation for partial: ${element.tagName}`);\n      console.log(\"Current partial element style after cleanup:\", element.style.cssText);\n\n      resolve();\n    };\n\n    element.addEventListener(\"animationend\", cleanup, { once: true });\n  });\n}\n\nfunction createKeyframes(transitionState: TransitionState, direction: \"in\" | \"out\"): string {\n  const { from, to } = transitionState;\n  const keyframeName = `xref-partial-${direction}-${Math.random().toString(36).substr(2, 9)}`;\n\n  const keyframeCSS = `@keyframes ${keyframeName} {\n    from {\n      ${Object.entries(from || {})\n        .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n        .join(\" \")}\n    }\n    to {\n      ${Object.entries(to || {})\n        .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n        .join(\" \")}\n    }\n  }`;\n\n  const styleElement = document.createElement(\"style\");\n  styleElement.textContent = keyframeCSS;\n  document.head.appendChild(styleElement);\n\n  return keyframeName;\n}\n\nfunction removeKeyframes(keyframeName: string) {\n  const styleElement = document.querySelector(`style:not([data-xref=\"true\"]):last-of-type`);\n  if (styleElement) {\n    styleElement.remove();\n  }\n}\n","import { Prefetcher, initPrefetcher } from \"./prefetch\";\nimport { handlePartials, hidePartials, showPartials } from \"./partials\";\nimport { camelToKebab } from \"./utils\";\n\nexport interface XrefOptions {\n  debug?: boolean;\n  updateHead?: boolean;\n  transition?: TransitionOptions;\n  prefetch?: PrefetchOptions;\n  head?: HeadOptions;\n}\n\nexport interface HeadOptions {\n  update?: boolean;\n  retrigger?: {\n    css?: boolean;\n    js?: boolean;\n    include?: string | RegExp;\n    exclude?: string | RegExp;\n  };\n}\nexport interface PrefetchOptions {\n  active: boolean;\n  delay: number;\n  event: string;\n  selector?: string;\n}\n\nexport interface TransitionOptions {\n  duration?: number;\n  delay?: number;\n  easing?: string;\n  timeline?: \"sequential\" | \"parallel\";\n  in?: TransitionState;\n  out?: TransitionState;\n  callback?: TransitionCallbacks;\n  state?: AnimationState;\n  swapHtml?: string;\n  partials?: PartialTransition[];\n}\n\nexport interface PartialTransition {\n  element: string;\n  duration?: number;\n  delay?: number;\n  easing?: string;\n  in?: TransitionState;\n  out?: TransitionState;\n}\n\nexport interface TransitionState {\n  from?: Record<string, string | number>;\n  to?: Record<string, string | number>;\n}\n\nexport interface AnimationState {\n  started: boolean;\n  playing: boolean;\n  paused: boolean;\n  finished: boolean;\n}\n\nexport interface TransitionCallbacks {\n  onEnter?: () => void;\n  onStart?: () => void;\n  onPlay?: () => void;\n  onPause?: () => void;\n  onFinish?: () => void;\n}\n\n/**\n * The main Xref class that handles\n * navigation and transitions.\n *\n * @returns The Xref instance.\n *\n * @description This is the main class that handles navigation and transitions.\n * It intercepts clicks on internal links, fetches the content of the linked page,\n * updates the document head and body, and performs transitions between the\n * old and new content. It also handles popstate events to support back\n * and forward navigation.\n */\nclass Xref {\n  private options: XrefOptions;\n  private styleElement: HTMLStyleElement;\n  private transitionCounter: number = 0;\n  private prefetcher: Prefetcher | null = null;\n  private animationState: AnimationState;\n\n  /**\n   * @description This is the constructor of the Xref class.\n   * It initializes the Xref instance with the given options,\n   * creates a style element to store the keyframes for transitions,\n   * and sets the initial animation state.\n   */\n  constructor(options: XrefOptions = {}) {\n    this.options = {\n      updateHead: true,\n      ...options,\n    };\n    this.styleElement = document.createElement(\"style\");\n    this.styleElement.setAttribute(\"data-xref\", \"true\");\n    document.head.appendChild(this.styleElement);\n    this.animationState = {\n      started: false,\n      playing: true,\n      paused: false,\n      finished: false,\n      ...(this.options.transition?.state as Partial<AnimationState>),\n    };\n    this.init();\n  }\n\n  /**\n   * @description This method initializes the Xref instance\n   * by intercepting clicks on internal links, handling popstate events,\n   * and initializing the prefetcher if prefetching is enabled.\n   */\n  private init() {\n    this.options.debug ? console.log(\"started -> init() Method\") : null;\n\n    this.interceptClicks();\n    this.handlePopState();\n\n    if (this.options.prefetch && this.options.prefetch.active) {\n      this.prefetcher = initPrefetcher(this.options.prefetch, this.options);\n    }\n  }\n\n  private currentKeyframeName: string | null = null;\n\n  /**\n   * @description This method creates keyframes\n   * for the given transition state\n   * and direction.\n   */\n  private createKeyframes(transitionState: TransitionState, direction: \"in\" | \"out\"): string {\n    const { from, to } = transitionState;\n    const keyframeName = `xref-${direction}-${++this.transitionCounter}`;\n\n    let keyframeCSS = `@keyframes ${keyframeName} {\n      from {\n        ${Object.entries(from || {})\n          .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n      to {\n        ${Object.entries(to || {})\n          .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n    }`;\n\n    this.options.debug ? console.log(\"Creating keyframe:\" + keyframeName) : null;\n    this.options.debug ? console.log(\"Keyframe CSS:\" + keyframeCSS) : null;\n\n    // Remove the previous keyframe if it exists\n    if (this.currentKeyframeName) {\n      this.removeKeyframes(this.currentKeyframeName);\n    }\n\n    // Append the new keyframe to the style element's content\n    this.styleElement.textContent = keyframeCSS;\n    this.currentKeyframeName = keyframeName;\n\n    this.options.debug ? console.log(\"Keyframe \" + keyframeName + \"appended to <style> element\") : null;\n    this.options.debug ? console.log(\"Current <style> content: \" + this.styleElement.textContent) : null;\n\n    return keyframeName;\n  }\n\n  /**\n   * @param keyframeName\n   * @description This method removes the keyframes\n   * with the given name from the style element.\n   */\n  private removeKeyframes(keyframeName: string) {\n    this.options.debug ? console.log(\"Removing keyframe: \" + keyframeName) : null;\n    this.styleElement.textContent = \"\";\n    this.options.debug ? console.log(\"Keyframe\" + keyframeName + \"removed\") : null;\n    this.options.debug ? console.log(\"Current <style> content after removal:\" + this.styleElement.textContent) : null;\n    this.currentKeyframeName = null;\n  }\n\n  /**\n   * @description This method intercepts clicks\n   * on internal links and prevents the default\n   * browser navigation behavior.\n   */\n  private interceptClicks() {\n    this.options.debug ? console.log(\"started -> interceptClicks() Method\") : null;\n\n    document.addEventListener(\"click\", (event) => {\n      const target = event.target as HTMLElement;\n      const anchor = target.closest(\"a\");\n      if (anchor && this.shouldIntercept(anchor as HTMLAnchorElement)) {\n        event.preventDefault();\n        this.runCallback(\"onEnter\");\n        this.navigate(anchor.href);\n      }\n    });\n  }\n\n  /**\n   * @description This method checks if the\n   * anchor should be intercepted based on\n   * the current URL and the anchor's href.\n   */\n  private shouldIntercept(anchor: HTMLAnchorElement): boolean {\n    this.options.debug ? console.log(\"started -> shouldIntercept() Method\") : null;\n\n    const currentUrl = new URL(window.location.href);\n    const linkUrl = new URL(anchor.href);\n\n    // Check if it's an internal link\n    const isSameOrigin = linkUrl.origin === currentUrl.origin;\n\n    // Check if it's not the current page or just a hash change\n    const isSamePage = linkUrl.pathname === currentUrl.pathname && linkUrl.search === currentUrl.search;\n    const isJustHashChange = isSamePage && linkUrl.hash !== currentUrl.hash;\n\n    // Intercept only if it's an internal link and not the same page or just a hash change\n    return isSameOrigin && !isSamePage && !isJustHashChange;\n  }\n\n  /**\n   * @description This method handles popstate events\n   * to support back and forward navigation.\n   */\n  private handlePopState() {\n    this.options.debug ? console.log(\"started -> handlePopState() Method\") : null;\n\n    window.addEventListener(\"popstate\", () => {\n      this.navigate(window.location.href, false);\n    });\n  }\n\n  /**\n   * @description This method navigates to the given URL\n   * and updates the page content. If prefetching is enabled\n   * and the content is already prefetched, it uses the\n   * prefetched content instead of fetching it again.\n   * If pushState is true, it updates the browser history.\n   */\n  public async navigate(url: string, pushState: boolean = true) {\n    this.options.debug ? console.log(\"started -> navigate() Method\") : null;\n\n    try {\n      let content: string | null = null;\n      if (this.prefetcher) {\n        content = this.prefetcher.getContent(url);\n      }\n\n      if (!content) {\n        content = await this.fetchPage(url);\n      }\n\n      if (content) {\n        if (pushState) {\n          history.pushState(null, \"\", url);\n        }\n        this.updatePage(content);\n      }\n    } catch (error) {\n      this.options.debug ? console.error(\"Navigation failed:\", error) : null;\n    }\n  }\n\n  /**\n   * @description This method fetches the content of the given URL\n   * and returns it as a string. It throws an error if the request fails.\n   */\n  private async fetchPage(url: string): Promise<string> {\n    this.options.debug ? console.log(\"started -> fetchPage() Method\") : null;\n\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    return await response.text();\n  }\n\n  /**\n   * @description This method updates the page content\n   * with the new content fetched from the server.\n   * It updates the head and body of the document\n   * based on the new content.\n   */\n  private async updatePage(content: string) {\n    this.options.debug ? console.log(\"started -> updatePage() Method\") : null;\n\n    const parser = new DOMParser();\n    const newDoc = parser.parseFromString(content, \"text/html\");\n\n    await this.updateBody(newDoc);\n    this.updateHead(newDoc);\n  }\n\n  /**\n   * @description This method updates the head of the document\n   * with the new head from the fetched content. It updates\n   * the title and other head elements based on the new content.\n   */\n  private updateHead(newDoc: Document) {\n    this.options.debug ? console.log(\"started -> updateHead() Method\") : null;\n\n    const oldHead = document.head;\n    const newHead = newDoc.head;\n\n    // Always update the title\n    document.title = newDoc.title;\n\n    if (this.options.head?.update === false) {\n      return;\n    }\n\n    // Remove old elements except our style element and title\n    Array.from(oldHead.children).forEach((child) => {\n      if (child !== this.styleElement && child.tagName !== \"TITLE\") {\n        child.remove();\n      }\n    });\n\n    // Add new elements\n    Array.from(newHead.children).forEach((child) => {\n      if (child.tagName !== \"STYLE\" && child.tagName !== \"TITLE\") {\n        const newChild = child.cloneNode(true) as HTMLElement;\n        oldHead.appendChild(newChild);\n        this.retriggerElement(newChild);\n      }\n    });\n\n    this.options.debug ? console.log(\"Head updated, xref style element preserved\") : null;\n  }\n\n  private retriggerElement(element: HTMLElement) {\n    const { retrigger } = this.options.head || {};\n    if (!retrigger) return;\n\n    const shouldRetrigger = (el: HTMLElement): boolean => {\n      if (retrigger.include && !el.matches(retrigger.include.toString())) return false;\n      if (retrigger.exclude && el.matches(retrigger.exclude.toString())) return false;\n      return true;\n    };\n\n    if (element.tagName === \"LINK\" && retrigger.css && shouldRetrigger(element)) {\n      const link = element as HTMLLinkElement;\n      link.href = link.href.split(\"?\")[0] + \"?t=\" + new Date().getTime();\n    } else if (element.tagName === \"SCRIPT\" && retrigger.js && shouldRetrigger(element)) {\n      const script = element as HTMLScriptElement;\n      const newScript = document.createElement(\"script\");\n      Array.from(script.attributes).forEach((attr) => newScript.setAttribute(attr.name, attr.value));\n      newScript.textContent = script.textContent;\n      script.parentNode?.replaceChild(newScript, script);\n    }\n  }\n\n  /**\n   * @description This method updates the body of the document\n   * with the new body from the fetched content. It updates\n   * the content of the swapHtml element based on the new content.\n   * It also performs the transition between the old and new content.\n   */\n  private async updateBody(newDoc: Document) {\n    this.options.debug ? console.log(\"started -> updateBody() Method\") : null;\n\n    const swapHtml = this.options.transition?.swapHtml || \"body\";\n    const oldElement = document.querySelector(swapHtml);\n    const newElement = newDoc.querySelector(swapHtml);\n\n    if (!oldElement || !newElement) {\n      this.options.debug ? console.error(`Element not found: ${swapHtml}`) : null;\n      return;\n    }\n\n    await this.performTransition(oldElement as HTMLElement, newElement as HTMLElement);\n\n    window.scrollTo(0, 0);\n  }\n\n  /**\n   * @description This method performs the transition\n   * between the old and new content by applying the\n   * in and out transitions to the elements.\n   * It also handles the transition timeline, duration,\n   * delay, and easing.\n   */\n  private async performTransition(oldElement: HTMLElement, newElement: HTMLElement) {\n    this.options.debug ? console.log(\"Started performTransition\") : null;\n    const transitionOptions = this.options.transition || {};\n    const duration = transitionOptions.duration || 300;\n    const delay = transitionOptions.delay || 0;\n    const easing = transitionOptions.easing || \"ease-in-out\";\n\n    let outTransition = transitionOptions.out;\n    let inTransition = transitionOptions.in;\n\n    this.setTransitionState(\"started\", true);\n    this.runCallback(\"onStart\");\n\n    // Get partials outside swapHtml\n    const partialsOutsideSwapHtml = this.getPartialsOutsideSwapHtml();\n\n    // 1. Animate partials \"out\"\n    if (partialsOutsideSwapHtml.length > 0) {\n      this.options.debug ? console.log(\"Applying partial out transitions\") : null;\n      const partialsOutPromise = handlePartials(partialsOutsideSwapHtml, document.body, document.body, this.options, \"out\");\n      \n      // Wait for the longest partial out animation to complete\n      await partialsOutPromise;\n      \n      // Hide partials after out animations\n      hidePartials(partialsOutsideSwapHtml, document.body);\n    }\n\n    // 2. Animate swapHtml out\n    if (outTransition) {\n      this.options.debug ? console.log(\"Applying main out transition\") : null;\n      await this.applyTransition(oldElement, outTransition, duration, delay, easing, \"out\");\n    }\n\n    // Update content of swapHtml\n    oldElement.innerHTML = newElement.innerHTML;\n    Array.from(newElement.attributes).forEach((attr) => {\n      if (attr.name !== \"style\") {\n        oldElement.setAttribute(attr.name, attr.value);\n      }\n    });\n\n    // 3. Animate swapHtml in\n    if (inTransition) {\n      this.options.debug ? console.log(\"Applying main in transition\") : null;\n      await this.applyTransition(oldElement, inTransition, duration, delay, easing, \"in\");\n    }\n\n    // 4. Animate partials \"in\"\n    if (partialsOutsideSwapHtml.length > 0) {\n      // this.options.debug ? console.log(\"Showing partials\") : null;\n      hidePartials(partialsOutsideSwapHtml, document.body);\n      // this.options.debug ? console.log(\"Applying partial in transitions\") : null;\n      // showPartials(partialsOutsideSwapHtml, document.body);\n      await handlePartials(partialsOutsideSwapHtml, document.body, document.body, this.options, \"in\");\n    }\n\n    // 5. Partials visible and DOM is ready with new Page\n    this.setTransitionState(\"finished\", true);\n    this.runCallback(\"onFinish\");\n\n    window.scrollTo(0, 0);\n  }\n\n\n  private getPartialsOutsideSwapHtml(): PartialTransition[] {\n    const swapHtml = this.options.transition?.swapHtml || \"body\";\n    const swapHtmlElement = document.querySelector(swapHtml);\n\n    return (this.options.transition?.partials || []).filter((partial) => {\n      const elements = document.querySelectorAll(partial.element);\n      return Array.from(elements).every((el) => !swapHtmlElement?.contains(el));\n    });\n  }\n\n  /**\n   * @description This method reverses the given transition\n   * by swapping the from and to states. This is useful\n   * for creating the \"out\" transition from the \"in\" transition.\n   */\n  private reverseTransition(transition: TransitionState): TransitionState {\n    return {\n      from: transition.to,\n      to: transition.from,\n    };\n  }\n\n  /**\n   * @description This method applies the transition to the element\n   * by creating the keyframes, setting the animation properties,\n   * and cleaning up after the animation is complete.\n   */\n  private applyTransition(element: HTMLElement, transitionState: TransitionState, duration: number, delay: number, easing: string, direction: \"in\" | \"out\"): Promise<void> {\n    return new Promise((resolve) => {\n      this.options.debug ? console.log(`Applying ${direction} transition`) : null;\n      const keyframeName = this.createKeyframes(transitionState, direction);\n      const animationCSS = `${keyframeName} ${duration}ms ${easing} ${delay}ms forwards`;\n\n      element.style.setProperty(\"animation\", animationCSS);\n      this.options.debug ? console.log(`Applied ${direction} animation: ${animationCSS}`) : null;\n      this.options.debug ? console.log(\"Current element style:\", element.style.cssText) : null;\n\n      // Force a reflow to ensure the animation is applied immediately\n      void element.offsetWidth;\n\n      const cleanup = () => {\n        this.options.debug ? console.log(`Animation end event fired for ${direction} transition`) : null;\n        element.style.removeProperty(\"animation\");\n\n        // Remove the keyframe immediately after the animation is complete\n        this.removeKeyframes(keyframeName);\n\n        if (direction === \"in\") {\n          Object.entries(transitionState.to || {}).forEach(([key, value]) => {\n            element.style.setProperty(camelToKebab(key), value as string);\n          });\n        }\n        this.options.debug ? console.log(`Cleaned up ${direction} animation`) : null;\n        this.options.debug ? console.log(\"Current element style after cleanup:\", element.style.cssText) : null;\n\n        resolve();\n      };\n\n      element.addEventListener(\"animationend\", cleanup, { once: true });\n    });\n  }\n\n  /**\n   * @description This method sets the transition state\n   * based on the given key and value. This is useful\n   * for tracking the state of the transition.\n   */\n  private setTransitionState(key: keyof AnimationState, value: boolean) {\n    this.animationState[key] = value;\n  }\n\n  private runCallback(callbackName: keyof TransitionCallbacks) {\n    const callback = this.options.transition?.callback?.[callbackName];\n    if (callback && typeof callback === \"function\") {\n      callback();\n    }\n  }\n\n  /**\n   * @description This method starts the transition\n   * and sets the animation state accordingly.\n   */\n  public startTransition() {\n    this.setTransitionState(\"started\", true);\n    this.setTransitionState(\"playing\", true);\n    this.setTransitionState(\"paused\", false);\n    this.setTransitionState(\"finished\", false);\n    this.runCallback(\"onStart\");\n    this.runCallback(\"onPlay\");\n  }\n\n  /**\n   * @description This method pauses the transition\n   * and sets the animation state accordingly.\n   */\n  public pauseTransition() {\n    if (this.animationState.playing) {\n      this.setTransitionState(\"playing\", false);\n      this.setTransitionState(\"paused\", true);\n      this.runCallback(\"onPause\");\n\n      // Pause transition\n      const element = document.querySelector(this.options.transition?.swapHtml || \"body\");\n      if (element instanceof HTMLElement) {\n        element.style.animationPlayState = \"paused\";\n      }\n    }\n  }\n\n  /**\n   * @description This method resumes the transition\n   * and sets the animation state accordingly.\n   */\n  public resumeTransition() {\n    if (this.animationState.paused) {\n      this.setTransitionState(\"playing\", true);\n      this.setTransitionState(\"paused\", false);\n      this.runCallback(\"onPlay\");\n\n      // Play transition\n      const element = document.querySelector(this.options.transition?.swapHtml || \"body\");\n      if (element instanceof HTMLElement) {\n        element.style.animationPlayState = \"running\";\n      }\n    }\n  }\n\n  /**\n   * @description This method finishes the transition\n   * and cleans up the animation\n   * */\n  public finishTransition() {\n    this.setTransitionState(\"playing\", false);\n    this.setTransitionState(\"paused\", false);\n    this.setTransitionState(\"finished\", true);\n    this.runCallback(\"onFinish\");\n  }\n}\n\nfunction xref(options: XrefOptions = {}): Xref {\n  return new Xref(options);\n}\n\nexport default xref;\n"],"names":["Prefetcher","constructor","options","xrefOptions","this","cache","Map","init","active","document","addEventListener","event","handleEvent","bind","link","target","closest","selector","shouldPrefetch","setTimeout","prefetch","href","delay","startsWith","window","location","origin","has","url","response","fetch","text","set","debug","console","log","error","getContent","get","camelToKebab","str","replace","toLowerCase","async","handlePartials","partials","oldElement","newElement","direction","partialPromises","flatMap","partial","index","elements","querySelectorAll","element","length","Array","from","map","mergedOptions","globalTransition","globalPartial","_a","Object","assign","duration","_b","_c","easing","_d","mergeOptions","transition","out","applyPartialTransition","in","style","removeProperty","Promise","resolve","all","hidePartials","forEach","el","visibility","transitionState","keyframeName","to","Math","random","toString","substr","keyframeCSS","entries","key","value","join","styleElement","createElement","textContent","head","appendChild","createKeyframes","animationCSS","setProperty","cssText","offsetWidth","tagName","querySelector","remove","removeKeyframes","once","Xref","transitionCounter","prefetcher","currentKeyframeName","updateHead","setAttribute","animationState","started","playing","paused","finished","state","interceptClicks","handlePopState","anchor","shouldIntercept","preventDefault","runCallback","navigate","currentUrl","URL","linkUrl","isSameOrigin","isSamePage","pathname","search","isJustHashChange","hash","pushState","content","fetchPage","history","updatePage","ok","Error","status","newDoc","DOMParser","parseFromString","updateBody","oldHead","newHead","title","update","children","child","newChild","cloneNode","retriggerElement","retrigger","shouldRetrigger","include","matches","exclude","css","split","Date","getTime","js","script","newScript","attributes","attr","name","parentNode","replaceChild","swapHtml","performTransition","scrollTo","transitionOptions","outTransition","inTransition","setTransitionState","partialsOutsideSwapHtml","getPartialsOutsideSwapHtml","partialsOutPromise","body","applyTransition","innerHTML","swapHtmlElement","filter","every","contains","reverseTransition","callbackName","callback","startTransition","pauseTransition","HTMLElement","animationPlayState","resumeTransition","finishTransition"],"mappings":"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"}