{"version":3,"file":"xref.umd.min.js","sources":["../src/xref.ts"],"sourcesContent":["interface XrefOptions {\n  updateHead?: boolean;\n  swapHtml?: string;\n  transition?: TransitionOptions;\n}\n\ninterface TransitionOptions {\n  duration?: number;\n  delay?: number;\n  easing?: string;\n  timeline?: \"sequential\" | \"parallel\";\n  in?: TransitionState;\n  out?: TransitionState;\n}\n\ninterface TransitionState {\n  from?: Record<string, string | number>;\n  to?: Record<string, string | number>;\n}\n\nclass Xref {\n  private options: XrefOptions;\n  private styleElement: HTMLStyleElement;\n  private transitionCounter: number = 0;\n\n  constructor(options: XrefOptions = {}) {\n    this.options = {\n      updateHead: true,\n      ...options,\n    };\n    this.styleElement = document.createElement(\"style\");\n    this.styleElement.setAttribute(\"data-xref\", \"true\");\n    document.head.appendChild(this.styleElement);\n    this.init();\n  }\n\n  private init() {\n    console.log(\"started -> init() Method\");\n\n    this.interceptClicks();\n    this.handlePopState();\n  }\n\n  // private currentKeyframes: { in?: string; out?: string } = {};\n  private currentKeyframeName: string | null = null;\n\n  private createKeyframes(transitionState: TransitionState, direction: \"in\" | \"out\"): string {\n    const { from, to } = transitionState;\n    const keyframeName = `xref-${direction}-${++this.transitionCounter}`;\n\n    let keyframeCSS = `@keyframes ${keyframeName} {\n      from {\n        ${Object.entries(from || {})\n          .map(([key, value]) => `${this.camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n      to {\n        ${Object.entries(to || {})\n          .map(([key, value]) => `${this.camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n    }`;\n\n    console.log(\"Creating keyframe:\" + keyframeName);\n    console.log(\"Keyframe CSS:\" + keyframeCSS);\n\n    // Remove the previous keyframe if it exists\n    if (this.currentKeyframeName) {\n      this.removeKeyframes(this.currentKeyframeName);\n    }\n\n    // Append the new keyframe to the style element's content\n    this.styleElement.textContent = keyframeCSS;\n    this.currentKeyframeName = keyframeName;\n\n    console.log(\"Keyframe \" + keyframeName + \"appended to <style> element\");\n    console.log(\"Current <style> content: \" + this.styleElement.textContent);\n\n    return keyframeName;\n  }\n\n  private removeKeyframes(keyframeName: string) {\n    console.log(\"Removing keyframe: \" + keyframeName);\n    this.styleElement.textContent = \"\";\n    console.log(\"Keyframe\" + keyframeName + \"removed\");\n    console.log(\"Current <style> content after removal:\" + this.styleElement.textContent);\n    this.currentKeyframeName = null;\n  }\n\n  private interceptClicks() {\n    console.log(\"started -> interceptClicks() Method\");\n\n    document.addEventListener(\"click\", (event) => {\n      const target = event.target as HTMLElement;\n      const anchor = target.closest(\"a\");\n      if (anchor && this.shouldIntercept(anchor)) {\n        event.preventDefault();\n        this.navigate(anchor.href);\n      }\n    });\n  }\n\n  private shouldIntercept(anchor: HTMLAnchorElement): boolean {\n    console.log(\"started -> shouldIntercept() Method\");\n\n    const isSameOrigin = anchor.origin === window.location.origin;\n    const isNotHash = anchor.hash === \"\";\n    return isSameOrigin && isNotHash;\n  }\n\n  private handlePopState() {\n    console.log(\"started -> handlePopState() Method\");\n\n    window.addEventListener(\"popstate\", () => {\n      this.navigate(window.location.href, false);\n    });\n  }\n\n  public async navigate(url: string, pushState: boolean = true) {\n    console.log(\"started -> navigate() Method\");\n\n    try {\n      const content = await this.fetchPage(url);\n      if (content) {\n        if (pushState) {\n          history.pushState(null, \"\", url);\n        }\n        this.updatePage(content);\n      }\n    } catch (error) {\n      console.error(\"Navigation failed:\", error);\n    }\n  }\n  private async fetchPage(url: string): Promise<string> {\n    console.log(\"started -> fetchPage() Method\");\n\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    return await response.text();\n  }\n\n  private updatePage(content: string) {\n    console.log(\"started -> updatePage() Method\");\n\n    const parser = new DOMParser();\n    const newDoc = parser.parseFromString(content, \"text/html\");\n\n    this.updateHead(newDoc);\n    this.updateBody(newDoc);\n  }\n\n  private updateHead(newDoc: Document) {\n    console.log(\"started -> updateHead() Method\");\n\n    const oldHead = document.head;\n    const newHead = newDoc.head;\n\n    // Always update the title\n    document.title = newDoc.title;\n\n    // If updateHead is false, don't update anything else in the head\n    if (this.options.updateHead === false) {\n      return;\n    }\n\n    // Remove old elements except our style element and title\n    Array.from(oldHead.children).forEach((child) => {\n      if (child !== this.styleElement && child.tagName !== \"TITLE\") {\n        child.remove();\n      }\n    });\n\n    // Add new elements\n    Array.from(newHead.children).forEach((child) => {\n      if (child.tagName !== \"STYLE\" && child.tagName !== \"TITLE\") {\n        oldHead.appendChild(child.cloneNode(true));\n      }\n    });\n\n    console.log(\"Head updated, xref style element preserved\");\n  }\n\n  private updateBody(newDoc: Document) {\n    console.log(\"started -> updateBody() Method\");\n\n    const swapHtml = this.options.swapHtml || \"body\";\n    const oldElement = document.querySelector(swapHtml);\n    const newElement = newDoc.querySelector(swapHtml);\n\n    if (!oldElement) {\n      console.error(`Old document does not contain element: ${swapHtml}`);\n      return;\n    }\n\n    if (!newElement) {\n      console.error(`New document does not contain element: ${swapHtml}`);\n      return;\n    }\n\n    // Type assertions\n    this.performTransition(oldElement as HTMLElement, newElement as HTMLElement);\n    /* this.removeInlineStylesFromRoot(); */\n  }\n\n  private performTransition(oldBody: HTMLElement, newBody: HTMLElement) {\n    console.log(\"Started performTransition\");\n    const transitionOptions = this.options.transition || {};\n    const duration = transitionOptions.duration || 300;\n    const delay = transitionOptions.delay || 0;\n    const easing = transitionOptions.easing || \"ease-in-out\";\n    const timeline = transitionOptions.timeline || \"sequential\";\n\n    let outTransition = transitionOptions.out;\n    let inTransition = transitionOptions.in;\n\n    // If no out transition is set, reverse the in transition\n    if (!outTransition && inTransition) {\n      outTransition = this.reverseTransition(inTransition);\n    }\n    // If no in transition is set, reverse the out transition\n    else if (!inTransition && outTransition) {\n      inTransition = this.reverseTransition(outTransition);\n    }\n\n    console.log(\"Transition options:\", { duration, delay, easing, timeline });\n    console.log(\"Out transition:\", outTransition);\n    console.log(\"In transition:\", inTransition);\n\n    if (outTransition) {\n      console.log(\"Applying out transition\");\n      this.applyTransition(oldBody, outTransition, duration, delay, easing, \"out\");\n    }\n\n    const applyInTransition = () => {\n      console.log(\"Applying in transition\");\n      // Remove the \"out\" animation\n      oldBody.style.removeProperty(\"animation\");\n\n      oldBody.innerHTML = newBody.innerHTML;\n      Array.from(newBody.attributes).forEach((attr) => {\n        if (attr.name !== \"style\") {\n          oldBody.setAttribute(attr.name, attr.value);\n        }\n      });\n\n      if (inTransition) {\n        this.applyTransition(oldBody, inTransition, duration, 0, easing, \"in\");\n      }\n    };\n\n    if (timeline === \"sequential\") {\n      console.log(`Setting timeout for in transition: ${duration + delay}ms`);\n      setTimeout(applyInTransition, duration / 2 + delay);\n    } else {\n      console.log(`Setting timeout for in transition: ${delay}ms (parallel)`);\n      setTimeout(applyInTransition, delay);\n    }\n  }\n\n  private reverseTransition(transition: TransitionState): TransitionState {\n    return {\n      from: transition.to,\n      to: transition.from,\n    };\n  }\n\n  private applyTransition(element: HTMLElement, transitionState: TransitionState, duration: number, delay: number, easing: string, direction: \"in\" | \"out\") {\n    console.log(`Applying ${direction} transition`);\n    const keyframeName = this.createKeyframes(transitionState, direction);\n    const animationCSS = `${keyframeName} ${duration}ms ${easing} ${delay}ms forwards`;\n\n    // Ensure we're setting the animation property correctly\n    element.style.setProperty(\"animation\", animationCSS);\n    console.log(`Applied ${direction} animation: ${animationCSS}`);\n    console.log(`Current element style:`, element.style.cssText);\n\n    // Force a reflow to ensure the animation is applied immediately\n    void element.offsetWidth;\n\n    const cleanup = () => {\n      console.log(`Animation end event fired for ${direction} transition`);\n      element.style.removeProperty(\"animation\");\n\n      // Remove the keyframe immediately after the animation is complete\n      this.removeKeyframes(keyframeName);\n\n      if (direction === \"in\") {\n        Object.entries(transitionState.to || {}).forEach(([key, value]) => {\n          element.style.setProperty(this.camelToKebab(key), value as string);\n        });\n      }\n      console.log(`Cleaned up ${direction} animation`);\n      console.log(`Current element style after cleanup:`, element.style.cssText);\n      element.removeEventListener(\"animationend\", cleanup);\n    };\n\n    element.addEventListener(\"animationend\", cleanup, { once: true });\n  }\n\n  public camelToKebab(str: string): string {\n    return str.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n  }\n}\n\nfunction xref(options: XrefOptions = {}): Xref {\n  return new Xref(options);\n}\n\nexport default xref;\n"],"names":["Xref","constructor","options","this","transitionCounter","currentKeyframeName","Object","assign","updateHead","styleElement","document","createElement","setAttribute","head","appendChild","init","console","log","interceptClicks","handlePopState","createKeyframes","transitionState","direction","from","to","keyframeName","keyframeCSS","entries","map","key","value","camelToKebab","join","removeKeyframes","textContent","addEventListener","event","anchor","target","closest","shouldIntercept","preventDefault","navigate","href","isSameOrigin","origin","window","location","isNotHash","hash","url","pushState","content","fetchPage","history","updatePage","error","response","fetch","ok","Error","status","text","newDoc","DOMParser","parseFromString","updateBody","oldHead","newHead","title","Array","children","forEach","child","tagName","remove","cloneNode","swapHtml","oldElement","querySelector","newElement","performTransition","oldBody","newBody","transitionOptions","transition","duration","delay","easing","timeline","outTransition","out","inTransition","in","reverseTransition","applyTransition","applyInTransition","style","removeProperty","innerHTML","attributes","attr","name","setTimeout","element","animationCSS","setProperty","cssText","offsetWidth","cleanup","removeEventListener","once","str","replace","toLowerCase"],"mappings":"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"}