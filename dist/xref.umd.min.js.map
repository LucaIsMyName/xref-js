{"version":3,"file":"xref.umd.min.js","sources":["../src/prefetch.ts","../src/utils.ts","../src/partials.ts","../src/xref.ts"],"sourcesContent":["import { XrefOptions } from \"./xref\";\n\ninterface PrefetchOptions {\n  event?: string;\n  delay?: number;\n  selector?: string;\n  active?: boolean;\n  media?: boolean;\n  css?: boolean;\n  js?: boolean;\n}\n\nexport class Prefetcher {\n  private cache: Map<string, string> = new Map();\n  private options: PrefetchOptions;\n  private xrefOptions: XrefOptions;\n\n  constructor(options: PrefetchOptions, xrefOptions: XrefOptions) {\n    this.options = options;\n    this.xrefOptions = xrefOptions;\n    this.init();\n  }\n\n  private init() {\n    if (!this.options.active) return;\n    document.addEventListener(this.options.event || \"mouseover\", this.handleEvent.bind(this));\n  }\n\n  private handleEvent(event: Event) {\n    const target = event.target as HTMLElement;\n    const link = target.closest(this.options.selector || \"a\") as HTMLAnchorElement | null;\n\n    if (link && this.shouldPrefetch(link)) {\n      setTimeout(() => this.prefetch(link.href), this.options.delay || 100);\n    }\n  }\n\n  private shouldPrefetch(link: HTMLAnchorElement): boolean {\n    return !!(link.href && link.href.startsWith(window.location.origin) && link.href !== window.location.href && !this.cache.has(link.href));\n  }\n\n  private async prefetch(url: string) {\n    try {\n      const response = await fetch(url);\n      const text = await response.text();\n      this.cache.set(url, text);\n      this.xrefOptions.debug ? console.log(`Prefetched HTML: ${url}`) : null;\n\n      const parser = new DOMParser();\n      const doc = parser.parseFromString(text, \"text/html\");\n\n      if (this.options.media) {\n        await this.prefetchMedia(doc);\n      }\n      if (this.options.css) {\n        await this.prefetchCss(doc);\n      }\n      if (this.options.js) {\n        await this.prefetchJs(doc);\n      }\n    } catch (error) {\n      this.xrefOptions.debug ? console.error(\"Failed to prefetch:\" + url, error) : null;\n    }\n  }\n\n  private async prefetchMedia(doc: Document) {\n    const mediaElements = doc.querySelectorAll(\"img, video, audio\");\n    const promises = Array.from(mediaElements).map(async (mediaElement) => {\n      const mediaSrc = (mediaElement as HTMLImageElement | HTMLVideoElement | HTMLAudioElement).src;\n      if (mediaSrc && !this.cache.has(mediaSrc) && !this.isCurrentlyLoaded(mediaSrc)) {\n        try {\n          await this.prefetchResource(mediaSrc);\n        } catch (error) {\n          this.xrefOptions.debug ? console.error(`Failed to prefetch media: ${mediaSrc}`, error) : null;\n        }\n      }\n    });\n    await Promise.all(promises);\n  }\n\n  private async prefetchCss(doc: Document) {\n    const cssElements = doc.querySelectorAll(\"link[rel=stylesheet]\");\n    const promises = Array.from(cssElements).map(async (cssElement) => {\n      const cssHref = (cssElement as HTMLLinkElement).href;\n      if (cssHref && !this.cache.has(cssHref) && !this.isCurrentlyLoaded(cssHref)) {\n        try {\n          await this.prefetchResource(cssHref);\n        } catch (error) {\n          this.xrefOptions.debug ? console.error(`Failed to prefetch CSS: ${cssHref}`, error) : null;\n        }\n      }\n    });\n    await Promise.all(promises);\n  }\n\n  private async prefetchJs(doc: Document) {\n    const jsElements = doc.querySelectorAll(\"script\");\n    const promises = Array.from(jsElements).map(async (jsElement) => {\n      const jsSrc = (jsElement as HTMLScriptElement).src;\n      if (jsSrc && !this.cache.has(jsSrc) && !this.isCurrentlyLoaded(jsSrc)) {\n        try {\n          await this.prefetchResource(jsSrc);\n        } catch (error) {\n          this.xrefOptions.debug ? console.error(`Failed to prefetch JS: ${jsSrc}`, error) : null;\n        }\n      }\n    });\n    await Promise.all(promises);\n  }\n\n  private async prefetchResource(url: string) {\n    try {\n      const response = await fetch(url);\n      const blob = await response.blob();\n      this.cache.set(url, URL.createObjectURL(blob));\n      this.xrefOptions.debug ? console.log(`Prefetched resource: ${url}`) : null;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private isCurrentlyLoaded(url: string): boolean {\n    const scripts = document.querySelectorAll(\"script\");\n    const links = document.querySelectorAll(\"link\");\n    const images = document.querySelectorAll(\"img\");\n    const audios = document.querySelectorAll(\"audio\");\n    const videos = document.querySelectorAll(\"video\");\n\n    return Array.from(scripts).some((script) => script.src === url) || Array.from(links).some((link) => link.href === url) || Array.from(images).some((img) => img.src === url) || Array.from(audios).some((audio) => audio.src === url) || Array.from(videos).some((video) => video.src === url);\n  }\n\n  public getContent(url: string): string | null {\n    return this.cache.get(url) || null;\n  }\n}\n\nexport function initPrefetcher(options: PrefetchOptions, xrefOptions: XrefOptions): Prefetcher {\n  return new Prefetcher(options, xrefOptions);\n}\n","/**\n * @description Convert camelCase to kebab-case\n */\nexport function camelToKebab(str: string): string {\n  return str.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\n/**\n * @description Convert kebab-case to camelCase\n */\nexport function kebabToCamel(str:string): string {\n  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n}\n","import { XrefOptions, TransitionOptions, TransitionState, PartialTransition } from \"./xref\";\nimport { camelToKebab } from \"./utils\";\n\n/**\n * \n * @description Handle partial transitions for a given element \n */\nexport async function handlePartials(partials: PartialTransition[], oldElement: HTMLElement, newElement: HTMLElement, options: XrefOptions, direction: \"in\" | \"out\") {\n  options.debug ? console.log(`Handling partials for ${direction} transition`) : null;\n\n  const partialPromises = partials.flatMap((partial, index) => {\n    const elements = oldElement.querySelectorAll(partial.element);\n    options.debug ? console.log(`Found ${elements.length} elements matching selector: ${partial.element}`) : null;\n\n    return Array.from(elements).map((element: any) => {\n      const mergedOptions = mergeOptions(partial, options.transition, index);\n      let transitionState = direction === \"out\" ? partial.out : partial.in;\n\n      // If the transition for the current direction is not defined, reverse the other direction\n      if (!transitionState) {\n        const oppositeTransition = direction === \"out\" ? partial.in : partial.out;\n        if (oppositeTransition) {\n          transitionState = reverseTransition(oppositeTransition);\n        }\n      }\n\n      if (transitionState) {\n        if (direction === \"in\") {\n          element.style.removeProperty(\"visibility\");\n        }\n        return applyPartialTransition(element as HTMLElement, transitionState, mergedOptions, direction);\n      }\n      return Promise.resolve();\n    });\n  });\n\n  await Promise.all(partialPromises);\n}\n\n/**\n * \n * @description Merge partial transition options with global transition options\n */\nfunction mergeOptions(partial: PartialTransition, globalTransition: TransitionOptions | undefined, index: number): TransitionOptions {\n  const globalPartial = globalTransition?.partials?.[index] || {};\n  return {\n    ...globalTransition,\n    ...globalPartial,\n    duration: partial.duration ?? globalTransition?.duration,\n    delay: partial.delay ?? globalTransition?.delay,\n    easing: partial.easing ?? globalTransition?.easing,\n  };\n}\n\n/**\n * \n * @description Reverse the transition state\n */\nfunction reverseTransition(transition: TransitionState): TransitionState {\n  return {\n    from: transition.to,\n    to: transition.from,\n  };\n}\n\n/**\n * \n * @description Hide partial elements\n */\nexport function hidePartials(partials: PartialTransition[], element: HTMLElement) {\n  partials.forEach((partial) => {\n    const elements = element.querySelectorAll(partial.element);\n    elements.forEach((el: HTMLElement | any) => {\n      el.style.visibility = \"hidden\";\n    });\n  });\n}\n\n/**\n * \n * @description Show partial elements\n */\nexport function showPartials(partials: PartialTransition[], element: HTMLElement) {\n  partials.forEach((partial) => {\n    const elements = element.querySelectorAll(partial.element);\n    elements.forEach((el: HTMLElement | any) => {\n      el.style.visibility = \"visible\";\n    });\n  });\n}\n\n/**\n * @description Apply partial transition to an element\n * */\nasync function applyPartialTransition(element: HTMLElement, transitionState: TransitionState, options: TransitionOptions, direction: \"in\" | \"out\"): Promise<void> {\n  return new Promise((resolve) => {\n    const duration = options.duration || 300;\n    const delay = options.delay ?? 0;\n    const easing = options.easing || \"ease-in-out\";\n\n    const keyframeName = createKeyframes(transitionState, direction);\n    const animationCSS = `${keyframeName} ${duration}ms ${easing} ${delay}ms forwards`;\n\n    element.style.setProperty(\"animation\", animationCSS);\n    console.log(`Applied ${direction} animation to partial: ${animationCSS}`);\n    console.log(\"Current partial element style:\", element.style.cssText);\n\n    // Force a reflow to ensure the animation is applied immediately\n    void element.offsetWidth;\n\n    const cleanup = () => {\n      console.log(`Animation end event fired for ${direction} transition on partial: ${element.tagName}`);\n      element.style.removeProperty(\"animation\");\n\n      // Remove the keyframe immediately after the animation is complete\n      removeKeyframes(keyframeName);\n\n      if (direction === \"in\") {\n        Object.entries(transitionState.to || {}).forEach(([key, value]) => {\n          element.style.setProperty(camelToKebab(key), value as string);\n        });\n      }\n      console.log(`Cleaned up ${direction} animation for partial: ${element.tagName}`);\n      console.log(\"Current partial element style after cleanup:\", element.style.cssText);\n\n      resolve();\n    };\n\n    element.addEventListener(\"animationend\", cleanup, { once: true });\n  });\n}\n\nfunction createKeyframes(transitionState: TransitionState, direction: \"in\" | \"out\"): string {\n  const { from, to } = transitionState;\n  let randomId = Math.random().toString(36).substr(2, 9);\n  const keyframeName = `xref-partial-${direction}-${randomId}`;\n\n  const keyframeCSS = `@keyframes ${keyframeName} {\n    from {\n      ${Object.entries(from || {})\n        .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n        .join(\" \")}\n    }\n    to {\n      ${Object.entries(to || {})\n        .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n        .join(\" \")}\n    }\n  }`;\n\n  const styleElement = document.createElement(\"style\");\n  styleElement.textContent = keyframeCSS;\n  styleElement.setAttribute(keyframeName, '');\n  document.head.appendChild(styleElement);\n\n  return keyframeName;\n}\n\nfunction removeKeyframes(keyframeName: string) {\n  // this is bad implementation, remove by keyframeName not :last-of-type selector\n  // const styleElement = document.querySelector(`style:not([data-xref=\"true\"]):last-of-type`);\n\n  const styleElement = document.querySelector(`style[${keyframeName}]`);\n  if (styleElement) {\n    styleElement.remove();\n  }\n}\n","import { Prefetcher, initPrefetcher } from \"./prefetch\";\nimport { handlePartials, hidePartials, showPartials } from \"./partials\";\nimport { camelToKebab } from \"./utils\";\n\nexport interface XrefOptions {\n  debug?: boolean;\n  updateHead?: boolean;\n  transition?: TransitionOptions;\n  prefetch?: PrefetchOptions;\n  head?: HeadOptions;\n}\n\nexport interface HeadOptions {\n  update?: boolean;\n  retrigger?: {\n    css?: boolean;\n    js?: boolean;\n    include?: string | RegExp;\n    exclude?: string | RegExp;\n  };\n}\n\nexport interface PrefetchOptions {\n  active: boolean;\n  delay: number;\n  event: string;\n  selector?: string;\n  media?: boolean;\n  css?: boolean;\n  js?: boolean;\n}\n\nexport interface TransitionOptions {\n  duration?: number;\n  delay?: number;\n  easing?: string;\n  timeline?: \"sequential\" | \"parallel\";\n  in?: TransitionState;\n  out?: TransitionState;\n  callback?: TransitionCallbacks;\n  state?: AnimationState;\n  swapHtml?: string;\n  partials?: PartialTransition[];\n}\n\nexport interface PartialTransition {\n  element: string;\n  duration?: number;\n  delay?: number;\n  easing?: string;\n  in?: TransitionState;\n  out?: TransitionState;\n}\n\nexport interface TransitionState {\n  from?: Record<string, string | number>;\n  to?: Record<string, string | number>;\n}\n\nexport interface AnimationState {\n  started: boolean;\n  playing: boolean;\n  paused: boolean;\n  finished: boolean;\n}\n\nexport interface TransitionCallbacks {\n  onEnter?: () => void;\n  onStart?: () => void;\n  onPlay?: () => void;\n  onPause?: () => void;\n  onFinish?: () => void;\n}\n\n/**\n * The main Xref class that handles\n * navigation and transitions.\n *\n * @returns The Xref instance.\n *\n * @description This is the main class that handles navigation and transitions.\n * It intercepts clicks on internal links, fetches the content of the linked page,\n * updates the document head and body, and performs transitions between the\n * old and new content. It also handles popstate events to support back\n * and forward navigation.\n */\nclass Xref {\n  private options: XrefOptions;\n  private styleElement: HTMLStyleElement;\n  private transitionCounter: number = 0;\n  private prefetcher: Prefetcher | null = null;\n  private animationState: AnimationState;\n\n  /**\n   * @description This is the constructor of the Xref class.\n   * It initializes the Xref instance with the given options,\n   * creates a style element to store the keyframes for transitions,\n   * and sets the initial animation state.\n   */\n  constructor(options: XrefOptions = {}) {\n    this.options = {\n      updateHead: true,\n      prefetch: {\n        active: false,\n        delay: 0,\n        event: \"mouseover\",\n        media: false,\n        css: false,\n        js: false,\n      },\n      ...options,\n    };\n    this.styleElement = document.createElement(\"style\");\n    this.styleElement.setAttribute(\"data-xref\", \"true\");\n    document.head.appendChild(this.styleElement);\n    this.animationState = {\n      started: false,\n      playing: true,\n      paused: false,\n      finished: false,\n      ...(this.options.transition?.state as Partial<AnimationState>),\n    };\n    this.init();\n  }\n\n  /**\n   * @description This method initializes the Xref instance\n   * by intercepting clicks on internal links, handling popstate events,\n   * and initializing the prefetcher if prefetching is enabled.\n   */\n  private init() {\n    this.options.debug ? console.log(\"started -> init() Method\") : null;\n\n    this.interceptClicks();\n    this.handlePopState();\n\n    if (this.options.prefetch && this.options.prefetch.active) {\n      this.prefetcher = initPrefetcher(this.options.prefetch, this.options);\n    }\n  }\n\n  private currentKeyframeName: string | null = null;\n\n  /**\n   * @description This method creates keyframes\n   * for the given transition state\n   * and direction.\n   */\n  private createKeyframes(transitionState: TransitionState, direction: \"in\" | \"out\"): string {\n    const { from, to } = transitionState;\n    const keyframeName = `xref-${direction}-${++this.transitionCounter}`;\n\n    let keyframeCSS = `@keyframes ${keyframeName} {\n      from {\n        ${Object.entries(from || {})\n          .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n      to {\n        ${Object.entries(to || {})\n          .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n    }`;\n\n    this.options.debug ? console.log(\"Creating keyframe:\" + keyframeName) : null;\n    this.options.debug ? console.log(\"Keyframe CSS:\" + keyframeCSS) : null;\n\n    // Remove the previous keyframe if it exists\n    if (this.currentKeyframeName) {\n      this.removeKeyframes(this.currentKeyframeName);\n    }\n\n    // Append the new keyframe to the style element's content\n    this.styleElement.textContent = keyframeCSS;\n    this.currentKeyframeName = keyframeName;\n\n    this.options.debug ? console.log(\"Keyframe \" + keyframeName + \"appended to <style> element\") : null;\n    this.options.debug ? console.log(\"Current <style> content: \" + this.styleElement.textContent) : null;\n\n    return keyframeName;\n  }\n\n  /**\n   * @param keyframeName\n   * @description This method removes the keyframes\n   * with the given name from the style element.\n   */\n  private removeKeyframes(keyframeName: string) {\n    this.options.debug ? console.log(\"Removing keyframe: \" + keyframeName) : null;\n    this.styleElement.textContent = \"\";\n    this.options.debug ? console.log(\"Keyframe\" + keyframeName + \"removed\") : null;\n    this.options.debug ? console.log(\"Current <style> content after removal:\" + this.styleElement.textContent) : null;\n    this.currentKeyframeName = null;\n  }\n\n  /**\n   * @description This method intercepts clicks\n   * on internal links and prevents the default\n   * browser navigation behavior.\n   */\n  private interceptClicks() {\n    this.options.debug ? console.log(\"started -> interceptClicks() Method\") : null;\n\n    document.addEventListener(\"click\", (event) => {\n      const target = event.target as HTMLElement;\n      const anchor = target.closest(\"a\");\n      if (anchor && this.shouldIntercept(anchor as HTMLAnchorElement)) {\n        event.preventDefault();\n        this.runCallback(\"onEnter\");\n        this.navigate(anchor.href);\n      }\n    });\n  }\n\n  /**\n   * @description This method checks if the\n   * anchor should be intercepted based on\n   * the current URL and the anchor's href.\n   */\n  private shouldIntercept(anchor: HTMLAnchorElement): boolean {\n    this.options.debug ? console.log(\"started -> shouldIntercept() Method\") : null;\n\n    const currentUrl = new URL(window.location.href);\n    const linkUrl = new URL(anchor.href);\n\n    // Check if it's an internal link\n    const isSameOrigin = linkUrl.origin === currentUrl.origin;\n\n    // Check if it's not the current page or just a hash change\n    const isSamePage = linkUrl.pathname === currentUrl.pathname && linkUrl.search === currentUrl.search;\n    const isJustHashChange = isSamePage && linkUrl.hash !== currentUrl.hash;\n\n    // Intercept only if it's an internal link and not the same page or just a hash change\n    return isSameOrigin && !isSamePage && !isJustHashChange;\n  }\n\n  /**\n   * @description This method handles popstate events\n   * to support back and forward navigation.\n   */\n  private handlePopState() {\n    this.options.debug ? console.log(\"started -> handlePopState() Method\") : null;\n\n    window.addEventListener(\"popstate\", () => {\n      this.navigate(window.location.href, false);\n    });\n  }\n\n  /**\n   * @description This method navigates to the given URL\n   * and updates the page content. If prefetching is enabled\n   * and the content is already prefetched, it uses the\n   * prefetched content instead of fetching it again.\n   * If pushState is true, it updates the browser history.\n   */\n  public async navigate(url: string, pushState: boolean = true) {\n    this.options.debug ? console.log(\"started -> navigate() Method\") : null;\n\n    try {\n      let content: string | null = null;\n      if (this.prefetcher) {\n        content = this.prefetcher.getContent(url);\n      }\n\n      if (!content) {\n        content = await this.fetchPage(url);\n      }\n\n      if (content) {\n        if (pushState) {\n          history.pushState(null, \"\", url);\n        }\n        this.updatePage(content);\n      }\n    } catch (error) {\n      this.options.debug ? console.error(\"Navigation failed:\", error) : null;\n    }\n  }\n\n  /**\n   * @description This method fetches the content of the given URL\n   * and returns it as a string. It throws an error if the request fails.\n   */\n  private async fetchPage(url: string): Promise<string> {\n    this.options.debug ? console.log(\"started -> fetchPage() Method\") : null;\n\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    return await response.text();\n  }\n\n  /**\n   * @description This method updates the page content\n   * with the new content fetched from the server.\n   * It updates the head and body of the document\n   * based on the new content.\n   */\n  private async updatePage(content: string) {\n    this.options.debug ? console.log(\"started -> updatePage() Method\") : null;\n\n    const parser = new DOMParser();\n    const newDoc = parser.parseFromString(content, \"text/html\");\n\n    // Update the body content\n    await this.updateBody(newDoc);\n\n    // Update the head content\n    this.updateHead(newDoc);\n\n    // Handle all scripts (both in head and body)\n    this.handleScripts(document, newDoc);\n\n    // Trigger a custom event to signal that the page has been updated\n    const event = new CustomEvent(\"xrefPageUpdated\");\n    document.dispatchEvent(event);\n\n    window.scrollTo(0, 0);\n  }\n\n  /**\n   * @description This method updates the head of the document\n   * with the new head from the fetched content. It updates\n   * the title and other head elements based on the new content.\n   */\n  private updateHead(newDoc: Document) {\n    this.options.debug ? console.log(\"started -> updateHead() Method\") : null;\n\n    const oldHead = document.head;\n    const newHead = newDoc.head;\n\n    // Always update the title\n    document.title = newDoc.title;\n\n    if (this.options.head?.update === false) {\n      return;\n    }\n\n    // Remove old elements except our style element and title\n    Array.from(oldHead.children).forEach((child) => {\n      if (child !== this.styleElement && child.tagName !== \"TITLE\") {\n        child.remove();\n      }\n    });\n\n    // Add new elements\n    Array.from(newHead.children).forEach((child) => {\n      if (/*child.tagName !== \"STYLE\" &&*/ child.tagName !== \"TITLE\") {\n        const newChild = child.cloneNode(true) as HTMLElement;\n        oldHead.appendChild(newChild);\n        this.retriggerElement(newChild);\n      }\n    });\n\n    this.options.debug ? console.log(\"Head updated, xref style element preserved\") : null;\n  }\n\n  private retriggerElement(element: HTMLElement) {\n    const { retrigger } = this.options.head || {};\n    if (!retrigger) return;\n\n    const shouldRetrigger = (el: HTMLElement): boolean => {\n      if (retrigger.include && !el.matches(retrigger.include.toString())) return false;\n      if (retrigger.exclude && el.matches(retrigger.exclude.toString())) return false;\n      return true;\n    };\n\n    if (element.tagName === \"LINK\" && retrigger.css && shouldRetrigger(element)) {\n      const link = element as HTMLLinkElement;\n      link.href = link.href.split(\"?\")[0] + \"?t=\" + new Date().getTime();\n    } else if (element.tagName === \"SCRIPT\" && retrigger.js && shouldRetrigger(element)) {\n      const script = element as HTMLScriptElement;\n      const newScript = document.createElement(\"script\");\n      Array.from(script.attributes).forEach((attr) => newScript.setAttribute(attr.name, attr.value));\n      newScript.textContent = script.textContent;\n      script.parentNode?.replaceChild(newScript, script);\n    }\n  }\n\n  /**\n   * @description This method updates the body of the document\n   * with the new body from the fetched content. It updates\n   * the content of the swapHtml element based on the new content.\n   * It also performs the transition between the old and new content.\n   */\n  private async updateBody(newDoc: Document) {\n    this.options.debug ? console.log(\"started -> updateBody() Method\") : null;\n\n    const swapHtml = this.options.transition?.swapHtml || \"body\";\n    const oldElement = document.querySelector(swapHtml);\n    const newElement = newDoc.querySelector(swapHtml);\n\n    if (!oldElement || !newElement) {\n      this.options.debug ? console.error(`Element not found: ${swapHtml}`) : null;\n      return;\n    }\n\n    await this.performTransition(oldElement as HTMLElement, newElement as HTMLElement);\n\n    // Update content of swapHtml\n    oldElement.innerHTML = newElement.innerHTML;\n    Array.from(newElement.attributes).forEach((attr) => {\n      if (attr.name !== \"style\") {\n        oldElement.setAttribute(attr.name, attr.value);\n      }\n    });\n  }\n\n  /**\n   * @description This method handles the scripts in the new content\n   * by comparing them with the old content and adding or removing\n   * scripts as needed. It also re-executes inline scripts.\n   * This is necessary to ensure that the scripts are executed\n   * when the new content is added to the document.\n   */\n  private handleScripts(oldDoc: Document, newDoc: Document) {\n    const handleScriptsInElement = (oldElement: Element, newElement: Element) => {\n      const oldScripts = Array.from(oldElement.querySelectorAll(\"script\"));\n      const newScripts = Array.from(newElement.querySelectorAll(\"script\"));\n\n      // Remove scripts that are in the old page but not in the new page\n      oldScripts.forEach((script) => {\n        const matchingNewScript = newScripts.find((newScript) => newScript.src === script.src && newScript.textContent === script.textContent);\n        if (!matchingNewScript) {\n          script.remove();\n        }\n      });\n\n      // Add new scripts or re-execute existing ones\n      newScripts.forEach((newScript) => {\n        const existingScript = oldScripts.find((script) => script.src === newScript.src && script.textContent === script.textContent);\n\n        if (existingScript) {\n          // Re-execute inline script\n          if (!newScript.src) {\n            const scriptElement = document.createElement(\"script\");\n            Array.from(newScript.attributes).forEach((attr) => scriptElement.setAttribute(attr.name, attr.value));\n            scriptElement.textContent = newScript.textContent;\n            existingScript.parentNode?.replaceChild(scriptElement, existingScript);\n          }\n          // For external scripts, we create a new script element to force a reload\n          else {\n            const scriptElement = document.createElement(\"script\");\n            Array.from(newScript.attributes).forEach((attr) => scriptElement.setAttribute(attr.name, attr.value));\n            existingScript.parentNode?.replaceChild(scriptElement, existingScript);\n          }\n        } else {\n          // Add new script\n          const scriptElement = document.createElement(\"script\");\n          Array.from(newScript.attributes).forEach((attr) => scriptElement.setAttribute(attr.name, attr.value));\n          scriptElement.textContent = newScript.textContent;\n          oldElement.appendChild(scriptElement);\n        }\n\n        // Remove duplicate styles\n        let allStyles = document.querySelectorAll(\"style\");\n        let allStylesArray = Array.from(allStyles);\n        let allStylesText = allStylesArray.map((style) => style.textContent);\n        let allStylesTextSet = new Set(allStylesText);\n        let allStylesTextArray = Array.from(allStylesTextSet);\n\n        allStylesArray.forEach((style) => {\n          let styleText = style.textContent;\n          let styleTextIndex = allStylesTextArray.indexOf(styleText);\n          if (styleTextIndex > 0) {\n            style.remove();\n          }\n        });\n      });\n    };\n\n    // Handle scripts in the head\n    handleScriptsInElement(oldDoc.head, newDoc.head);\n\n    // Handle scripts in the body\n    handleScriptsInElement(oldDoc.body, newDoc.body);\n  }\n\n  /**\n   * @description This method performs the transition\n   * between the old and new content by applying the\n   * in and out transitions to the elements.\n   * It also handles the transition timeline, duration,\n   * delay, and easing.\n   */\n  private async performTransition(oldElement: HTMLElement, newElement: HTMLElement) {\n    this.options.debug ? console.log(\"Started performTransition\") : null;\n    const transitionOptions = this.options.transition || {};\n    const duration = transitionOptions.duration || 300;\n    const delay = transitionOptions.delay || 0;\n    const easing = transitionOptions.easing || \"ease-in-out\";\n\n    let outTransition = transitionOptions.out;\n    let inTransition = transitionOptions.in;\n\n    this.setTransitionState(\"started\", true);\n    this.runCallback(\"onStart\");\n\n    // Get partials outside swapHtml\n    const partialsOutsideSwapHtml = this.getPartialsOutsideSwapHtml();\n\n    // 1. Animate partials \"out\"\n    if (partialsOutsideSwapHtml.length > 0) {\n      this.options.debug ? console.log(\"Applying partial out transitions\") : null;\n      const partialsOutPromise = handlePartials(partialsOutsideSwapHtml, document.body, document.body, this.options, \"out\");\n\n      // Wait for the longest partial out animation to complete\n      await partialsOutPromise;\n\n      // Hide partials after out animations\n      hidePartials(partialsOutsideSwapHtml, document.body);\n    }\n\n    // 2. Animate swapHtml out\n    if (outTransition) {\n      this.options.debug ? console.log(\"Applying main out transition\") : null;\n      await this.applyTransition(oldElement, outTransition, duration, delay, easing, \"out\");\n    }\n\n    // Update content of swapHtml\n    oldElement.innerHTML = newElement.innerHTML;\n    Array.from(newElement.attributes).forEach((attr) => {\n      if (attr.name !== \"style\") {\n        oldElement.setAttribute(attr.name, attr.value);\n      }\n    });\n\n    // 3. Animate swapHtml in\n    if (inTransition) {\n      this.options.debug ? console.log(\"Applying main in transition\") : null;\n      await this.applyTransition(oldElement, inTransition, duration, delay, easing, \"in\");\n    }\n\n    // 4. Animate partials \"in\"\n    if (partialsOutsideSwapHtml.length > 0) {\n      hidePartials(partialsOutsideSwapHtml, document.body);\n      await handlePartials(partialsOutsideSwapHtml, document.body, document.body, this.options, \"in\");\n    }\n\n    // 5. Partials visible and DOM is ready with new Page\n    this.setTransitionState(\"finished\", true);\n    this.runCallback(\"onFinish\");\n\n    window.scrollTo(0, 0);\n  }\n\n  private getPartialsOutsideSwapHtml(): PartialTransition[] {\n    const swapHtml = this.options.transition?.swapHtml || \"body\";\n    const swapHtmlElement = document.querySelector(swapHtml);\n\n    return (this.options.transition?.partials || []).filter((partial) => {\n      const elements = document.querySelectorAll(partial.element);\n      return Array.from(elements).every((el) => !swapHtmlElement?.contains(el));\n    });\n  }\n\n  /**\n   * @description This method reverses the given transition\n   * by swapping the from and to states. This is useful\n   * for creating the \"out\" transition from the \"in\" transition.\n   */\n  private reverseTransition(transition: TransitionState): TransitionState {\n    return {\n      from: transition.to,\n      to: transition.from,\n    };\n  }\n\n  /**\n   * @description This method applies the transition to the element\n   * by creating the keyframes, setting the animation properties,\n   * and cleaning up after the animation is complete.\n   */\n  private applyTransition(element: HTMLElement, transitionState: TransitionState, duration: number, delay: number, easing: string, direction: \"in\" | \"out\"): Promise<void> {\n    return new Promise((resolve) => {\n      this.options.debug ? console.log(`Applying ${direction} transition`) : null;\n      const keyframeName = this.createKeyframes(transitionState, direction);\n      const animationCSS = `${keyframeName} ${duration}ms ${easing} ${delay}ms forwards`;\n\n      element.style.setProperty(\"animation\", animationCSS);\n      this.options.debug ? console.log(`Applied ${direction} animation: ${animationCSS}`) : null;\n      this.options.debug ? console.log(\"Current element style:\", element.style.cssText) : null;\n\n      // Force a reflow to ensure the animation is applied immediately\n      void element.offsetWidth;\n\n      const cleanup = () => {\n        this.options.debug ? console.log(`Animation end event fired for ${direction} transition`) : null;\n        element.style.removeProperty(\"animation\");\n\n        // Remove the keyframe immediately after the animation is complete\n        this.removeKeyframes(keyframeName);\n\n        if (direction === \"in\") {\n          Object.entries(transitionState.to || {}).forEach(([key, value]) => {\n            element.style.setProperty(camelToKebab(key), value as string);\n          });\n        }\n        this.options.debug ? console.log(`Cleaned up ${direction} animation`) : null;\n        this.options.debug ? console.log(\"Current element style after cleanup:\", element.style.cssText) : null;\n\n        resolve();\n      };\n\n      element.addEventListener(\"animationend\", cleanup, { once: true });\n    });\n  }\n\n  /**\n   * @description This method sets the transition state\n   * based on the given key and value. This is useful\n   * for tracking the state of the transition.\n   */\n  private setTransitionState(key: keyof AnimationState, value: boolean) {\n    this.animationState[key] = value;\n  }\n\n  /**\n   *\n   * @description This method runs the callback with the given name\n   * if it exists in the transition options. This is useful for\n   * running custom code at different stages of the transition.\n   */\n  private runCallback(callbackName: keyof TransitionCallbacks) {\n    const callback = this.options.transition?.callback?.[callbackName];\n    if (callback && typeof callback === \"function\") {\n      callback();\n    }\n  }\n\n  /**\n   * @description This method starts the transition\n   * and sets the animation state accordingly.\n   */\n  public startTransition() {\n    this.setTransitionState(\"started\", true);\n    this.setTransitionState(\"playing\", true);\n    this.setTransitionState(\"paused\", false);\n    this.setTransitionState(\"finished\", false);\n    this.runCallback(\"onStart\");\n    this.runCallback(\"onPlay\");\n  }\n\n  /**\n   * @description This method pauses the transition\n   * and sets the animation state accordingly.\n   */\n  public pauseTransition() {\n    if (this.animationState.playing) {\n      this.setTransitionState(\"playing\", false);\n      this.setTransitionState(\"paused\", true);\n      this.runCallback(\"onPause\");\n\n      // Pause transition\n      const element = document.querySelector(this.options.transition?.swapHtml || \"body\");\n      if (element instanceof HTMLElement) {\n        element.style.animationPlayState = \"paused\";\n      }\n    }\n  }\n\n  /**\n   * @description This method resumes the transition\n   * and sets the animation state accordingly.\n   */\n  public resumeTransition() {\n    if (this.animationState.paused) {\n      this.setTransitionState(\"playing\", true);\n      this.setTransitionState(\"paused\", false);\n      this.runCallback(\"onPlay\");\n\n      // Play transition\n      const element = document.querySelector(this.options.transition?.swapHtml || \"body\");\n      if (element instanceof HTMLElement) {\n        element.style.animationPlayState = \"running\";\n      }\n    }\n  }\n\n  /**\n   * @description This method finishes the transition\n   * and cleans up the animation\n   * */\n  public finishTransition() {\n    this.setTransitionState(\"playing\", false);\n    this.setTransitionState(\"paused\", false);\n    this.setTransitionState(\"finished\", true);\n    this.runCallback(\"onFinish\");\n  }\n}\n\n/**\n * @description This function creates a new Xref instance\n * with the given options and returns it. This is the main\n * entry point for using Xref in a project.\n */\nfunction xref(options: XrefOptions = {}): Xref {\n  return new Xref(options);\n}\n\nexport default xref;\n"],"names":["Prefetcher","constructor","options","xrefOptions","this","cache","Map","init","active","document","addEventListener","event","handleEvent","bind","link","target","closest","selector","shouldPrefetch","setTimeout","prefetch","href","delay","startsWith","window","location","origin","has","url","response","fetch","text","set","debug","console","log","doc","DOMParser","parseFromString","media","prefetchMedia","css","prefetchCss","js","prefetchJs","error","mediaElements","querySelectorAll","promises","Array","from","map","async","mediaElement","mediaSrc","src","isCurrentlyLoaded","prefetchResource","Promise","all","cssElements","cssElement","cssHref","jsElements","jsElement","jsSrc","blob","URL","createObjectURL","scripts","links","images","audios","videos","some","script","img","audio","video","getContent","get","camelToKebab","str","replace","toLowerCase","handlePartials","partials","oldElement","newElement","direction","partialPromises","flatMap","partial","index","elements","element","length","mergedOptions","globalTransition","globalPartial","_a","Object","assign","duration","_b","_c","easing","_d","mergeOptions","transition","transitionState","out","in","oppositeTransition","to","style","removeProperty","resolve","keyframeName","randomId","Math","random","toString","substr","keyframeCSS","entries","key","value","join","styleElement","createElement","textContent","setAttribute","head","appendChild","createKeyframes","animationCSS","setProperty","cssText","offsetWidth","cleanup","tagName","querySelector","remove","removeKeyframes","forEach","once","applyPartialTransition","hidePartials","el","visibility","Xref","transitionCounter","prefetcher","currentKeyframeName","updateHead","animationState","started","playing","paused","finished","state","interceptClicks","handlePopState","anchor","shouldIntercept","preventDefault","runCallback","navigate","currentUrl","linkUrl","isSameOrigin","isSamePage","pathname","search","isJustHashChange","hash","pushState","content","fetchPage","history","updatePage","ok","Error","status","newDoc","updateBody","handleScripts","CustomEvent","dispatchEvent","scrollTo","oldHead","newHead","title","update","children","child","newChild","cloneNode","retriggerElement","retrigger","shouldRetrigger","include","matches","exclude","split","Date","getTime","newScript","attributes","attr","name","parentNode","replaceChild","swapHtml","performTransition","innerHTML","oldDoc","handleScriptsInElement","oldScripts","newScripts","find","existingScript","scriptElement","allStyles","allStylesArray","allStylesText","allStylesTextSet","Set","allStylesTextArray","styleText","indexOf","body","transitionOptions","outTransition","inTransition","setTransitionState","partialsOutsideSwapHtml","getPartialsOutsideSwapHtml","partialsOutPromise","applyTransition","swapHtmlElement","filter","every","contains","reverseTransition","callbackName","callback","startTransition","pauseTransition","HTMLElement","animationPlayState","resumeTransition","finishTransition"],"mappings":"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"}