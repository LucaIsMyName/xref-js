{"version":3,"file":"xref.umd.min.js","sources":["../src/prefetch.ts","../src/utils.ts","../src/partials.ts","../src/xref.ts"],"sourcesContent":["import { XrefOptions } from \"./xref\";\n\ninterface PrefetchOptions {\n  event?: string;\n  delay?: number;\n  selector?: string;\n  active?: boolean;\n}\n\nexport class Prefetcher {\n  private cache: Map<string, string> = new Map();\n  private options: PrefetchOptions;\n  private xrefOptions: XrefOptions;\n\n  /**\n   *\n   * @description Initializes the prefetcher\n   * with the given options.\n   */\n  constructor(options: PrefetchOptions, xrefOptions: XrefOptions) {\n    this.options = options;\n    this.xrefOptions = xrefOptions;\n    this.init();\n  }\n\n  /**\n   * @description Initializes the prefetcher by\n   * adding an event listener to the document.\n   */\n  private init() {\n    if (!this.options.active) return;\n    document.addEventListener(this.options.event || \"mouseover\", this.handleEvent.bind(this));\n  }\n\n  /**\n   *\n   * @description Handles the event by checking if the target\n   * is an anchor element and if it should be prefetched.\n   */\n  private handleEvent(event: Event) {\n    const target = event.target as HTMLElement;\n    const link = target.closest(this.options.selector || \"a\") as HTMLAnchorElement | null;\n\n    if (link && this.shouldPrefetch(link)) {\n      setTimeout(() => this.prefetch(link.href), this.options.delay || 100);\n    }\n  }\n\n  /**\n   *\n   * @description Checks if the link should be prefetched.\n   * It should be prefetched if it's an anchor element, it's\n   * not the current page, and it's not already in the cache.\n   */\n  private shouldPrefetch(link: HTMLAnchorElement): boolean {\n    return !!(link.href && link.href.startsWith(window.location.origin) && link.href !== window.location.href && !this.cache.has(link.href));\n  }\n\n  /**\n   *\n   * @description Fetches the content of the given URL\n   * and stores it in the cache. If the fetch fails, it logs\n   * an error to the console.\n   */\n  private async prefetch(url: string) {\n    try {\n      const response = await fetch(url);\n      const text = await response.text();\n      this.cache.set(url, text);\n      this.xrefOptions.debug ? console.log(`Prefetched: ${url}`) : null;\n    } catch (error) {\n      this.xrefOptions.debug ? console.error(\"Failed to prefetch:\" + url, error) : null;\n    }\n  }\n\n  /**\n   *\n   * @description Gets the content of the given URL\n   * from the cache. If the content is not in the cache,\n   * it returns null. Otherwise, it returns the content.\n   * This method is used by the Xref instance to get the\n   * content of a URL before navigating to it.\n   */\n  public getContent(url: string): string | null {\n    return this.cache.get(url) || null;\n  }\n}\n\nexport function initPrefetcher(options: PrefetchOptions, xrefOptions: XrefOptions): Prefetcher {\n  return new Prefetcher(options, xrefOptions);\n}\n","/**\n *\n * @description Convert camelCase to kebab-case\n */\nexport function camelToKebab(str: string): string {\n  return str.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n","import { XrefOptions, TransitionOptions, TransitionState, PartialTransition } from \"./xref\";\nimport { camelToKebab } from \"./utils\";\n\nexport async function handlePartials(partials: PartialTransition[], oldElement: HTMLElement, newElement: HTMLElement, options: XrefOptions, direction: \"in\" | \"out\") {\n  options.debug ? console.log(`Handling partials for ${direction} transition`) : null;\n\n  const partialPromises = partials.flatMap((partial, index) => {\n    const elements = oldElement.querySelectorAll(partial.element);\n    options.debug ? console.log(`Found ${elements.length} elements matching selector: ${partial.element}`) : null;\n\n    return Array.from(elements).map((element) => {\n      const mergedOptions = mergeOptions(partial, options.transition, index);\n      let transitionState = direction === \"out\" ? partial.out : partial.in;\n\n      // If the transition for the current direction is not defined, reverse the other direction\n      if (!transitionState) {\n        const oppositeTransition = direction === \"out\" ? partial.in : partial.out;\n        if (oppositeTransition) {\n          transitionState = reverseTransition(oppositeTransition);\n        }\n      }\n\n      if (transitionState) {\n        if (direction === \"in\") {\n          element.style.removeProperty(\"visibility\");\n        }\n        return applyPartialTransition(element as HTMLElement, transitionState, mergedOptions, direction);\n      }\n      return Promise.resolve();\n    });\n  });\n\n  await Promise.all(partialPromises);\n}\n\nfunction mergeOptions(partial: PartialTransition, globalTransition: TransitionOptions | undefined, index: number): TransitionOptions {\n  const globalPartial = globalTransition?.partials?.[index] || {};\n  return {\n    ...globalTransition,\n    ...globalPartial,\n    duration: partial.duration ?? globalTransition?.duration,\n    delay: partial.delay ?? globalTransition?.delay,\n    easing: partial.easing ?? globalTransition?.easing,\n  };\n}\n\nfunction reverseTransition(transition: TransitionState): TransitionState {\n  return {\n    from: transition.to,\n    to: transition.from,\n  };\n}\n\nexport function hidePartials(partials: PartialTransition[], element: HTMLElement) {\n  partials.forEach((partial) => {\n    const elements = element.querySelectorAll(partial.element);\n    elements.forEach((el: HTMLElement | any) => {\n      el.style.visibility = \"hidden\";\n    });\n  });\n}\n\nexport function showPartials(partials: PartialTransition[], element: HTMLElement) {\n  partials.forEach((partial) => {\n    const elements = element.querySelectorAll(partial.element);\n    elements.forEach((el: HTMLElement | any) => {\n      el.style.visibility = \"visible\";\n    });\n  });\n}\n\nasync function applyPartialTransition(element: HTMLElement, transitionState: TransitionState, options: TransitionOptions, direction: \"in\" | \"out\"): Promise<void> {\n  return new Promise((resolve) => {\n    const duration = options.duration || 300;\n    const delay = options.delay ?? 0;\n    const easing = options.easing || \"ease-in-out\";\n\n    const keyframeName = createKeyframes(transitionState, direction);\n    const animationCSS = `${keyframeName} ${duration}ms ${easing} ${delay}ms forwards`;\n\n    element.style.setProperty(\"animation\", animationCSS);\n    console.log(`Applied ${direction} animation to partial: ${animationCSS}`);\n    console.log(\"Current partial element style:\", element.style.cssText);\n\n    // Force a reflow to ensure the animation is applied immediately\n    void element.offsetWidth;\n\n    const cleanup = () => {\n      console.log(`Animation end event fired for ${direction} transition on partial: ${element.tagName}`);\n      element.style.removeProperty(\"animation\");\n\n      // Remove the keyframe immediately after the animation is complete\n      removeKeyframes(keyframeName);\n\n      if (direction === \"in\") {\n        Object.entries(transitionState.to || {}).forEach(([key, value]) => {\n          element.style.setProperty(camelToKebab(key), value as string);\n        });\n      }\n      console.log(`Cleaned up ${direction} animation for partial: ${element.tagName}`);\n      console.log(\"Current partial element style after cleanup:\", element.style.cssText);\n\n      resolve();\n    };\n\n    element.addEventListener(\"animationend\", cleanup, { once: true });\n  });\n}\n\nfunction createKeyframes(transitionState: TransitionState, direction: \"in\" | \"out\"): string {\n  const { from, to } = transitionState;\n  const keyframeName = `xref-partial-${direction}-${Math.random().toString(36).substr(2, 9)}`;\n\n  const keyframeCSS = `@keyframes ${keyframeName} {\n    from {\n      ${Object.entries(from || {})\n        .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n        .join(\" \")}\n    }\n    to {\n      ${Object.entries(to || {})\n        .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n        .join(\" \")}\n    }\n  }`;\n\n  const styleElement = document.createElement(\"style\");\n  styleElement.textContent = keyframeCSS;\n  document.head.appendChild(styleElement);\n\n  return keyframeName;\n}\n\nfunction removeKeyframes(keyframeName: string) {\n  const styleElement = document.querySelector(`style:not([data-xref=\"true\"]):last-of-type`);\n  if (styleElement) {\n    styleElement.remove();\n  }\n}\n","import { Prefetcher, initPrefetcher } from \"./prefetch\";\nimport { handlePartials, hidePartials, showPartials } from \"./partials\";\nimport { camelToKebab } from \"./utils\";\n\nexport interface XrefOptions {\n  debug?: boolean;\n  updateHead?: boolean;\n  transition?: TransitionOptions;\n  prefetch?: PrefetchOptions;\n  head?: HeadOptions;\n}\n\nexport interface HeadOptions {\n  update?: boolean;\n  retrigger?: {\n    css?: boolean;\n    js?: boolean;\n    include?: string | RegExp;\n    exclude?: string | RegExp;\n  };\n}\nexport interface PrefetchOptions {\n  active: boolean;\n  delay: number;\n  event: string;\n  selector?: string;\n}\n\nexport interface TransitionOptions {\n  duration?: number;\n  delay?: number;\n  easing?: string;\n  timeline?: \"sequential\" | \"parallel\";\n  in?: TransitionState;\n  out?: TransitionState;\n  callback?: TransitionCallbacks;\n  state?: AnimationState;\n  swapHtml?: string;\n  partials?: PartialTransition[];\n}\n\nexport interface PartialTransition {\n  element: string;\n  duration?: number;\n  delay?: number;\n  easing?: string;\n  in?: TransitionState;\n  out?: TransitionState;\n}\n\nexport interface TransitionState {\n  from?: Record<string, string | number>;\n  to?: Record<string, string | number>;\n}\n\nexport interface AnimationState {\n  started: boolean;\n  playing: boolean;\n  paused: boolean;\n  finished: boolean;\n}\n\nexport interface TransitionCallbacks {\n  onEnter?: () => void;\n  onStart?: () => void;\n  onPlay?: () => void;\n  onPause?: () => void;\n  onFinish?: () => void;\n}\n\n/**\n * The main Xref class that handles\n * navigation and transitions.\n *\n * @returns The Xref instance.\n *\n * @description This is the main class that handles navigation and transitions.\n * It intercepts clicks on internal links, fetches the content of the linked page,\n * updates the document head and body, and performs transitions between the\n * old and new content. It also handles popstate events to support back\n * and forward navigation.\n */\nclass Xref {\n  private options: XrefOptions;\n  private styleElement: HTMLStyleElement;\n  private transitionCounter: number = 0;\n  private prefetcher: Prefetcher | null = null;\n  private animationState: AnimationState;\n\n  /**\n   * @description This is the constructor of the Xref class.\n   * It initializes the Xref instance with the given options,\n   * creates a style element to store the keyframes for transitions,\n   * and sets the initial animation state.\n   */\n  constructor(options: XrefOptions = {}) {\n    this.options = {\n      updateHead: true,\n      ...options,\n    };\n    this.styleElement = document.createElement(\"style\");\n    this.styleElement.setAttribute(\"data-xref\", \"true\");\n    document.head.appendChild(this.styleElement);\n    this.animationState = {\n      started: false,\n      playing: true,\n      paused: false,\n      finished: false,\n      ...(this.options.transition?.state as Partial<AnimationState>),\n    };\n    this.init();\n  }\n\n  /**\n   * @description This method initializes the Xref instance\n   * by intercepting clicks on internal links, handling popstate events,\n   * and initializing the prefetcher if prefetching is enabled.\n   */\n  private init() {\n    this.options.debug ? console.log(\"started -> init() Method\") : null;\n\n    this.interceptClicks();\n    this.handlePopState();\n\n    if (this.options.prefetch && this.options.prefetch.active) {\n      this.prefetcher = initPrefetcher(this.options.prefetch, this.options);\n    }\n  }\n\n  private currentKeyframeName: string | null = null;\n\n  /**\n   * @description This method creates keyframes\n   * for the given transition state\n   * and direction.\n   */\n  private createKeyframes(transitionState: TransitionState, direction: \"in\" | \"out\"): string {\n    const { from, to } = transitionState;\n    const keyframeName = `xref-${direction}-${++this.transitionCounter}`;\n\n    let keyframeCSS = `@keyframes ${keyframeName} {\n      from {\n        ${Object.entries(from || {})\n          .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n      to {\n        ${Object.entries(to || {})\n          .map(([key, value]) => `${camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n    }`;\n\n    this.options.debug ? console.log(\"Creating keyframe:\" + keyframeName) : null;\n    this.options.debug ? console.log(\"Keyframe CSS:\" + keyframeCSS) : null;\n\n    // Remove the previous keyframe if it exists\n    if (this.currentKeyframeName) {\n      this.removeKeyframes(this.currentKeyframeName);\n    }\n\n    // Append the new keyframe to the style element's content\n    this.styleElement.textContent = keyframeCSS;\n    this.currentKeyframeName = keyframeName;\n\n    this.options.debug ? console.log(\"Keyframe \" + keyframeName + \"appended to <style> element\") : null;\n    this.options.debug ? console.log(\"Current <style> content: \" + this.styleElement.textContent) : null;\n\n    return keyframeName;\n  }\n\n  /**\n   * @param keyframeName\n   * @description This method removes the keyframes\n   * with the given name from the style element.\n   */\n  private removeKeyframes(keyframeName: string) {\n    this.options.debug ? console.log(\"Removing keyframe: \" + keyframeName) : null;\n    this.styleElement.textContent = \"\";\n    this.options.debug ? console.log(\"Keyframe\" + keyframeName + \"removed\") : null;\n    this.options.debug ? console.log(\"Current <style> content after removal:\" + this.styleElement.textContent) : null;\n    this.currentKeyframeName = null;\n  }\n\n  /**\n   * @description This method intercepts clicks\n   * on internal links and prevents the default\n   * browser navigation behavior.\n   */\n  private interceptClicks() {\n    this.options.debug ? console.log(\"started -> interceptClicks() Method\") : null;\n\n    document.addEventListener(\"click\", (event) => {\n      const target = event.target as HTMLElement;\n      const anchor = target.closest(\"a\");\n      if (anchor && this.shouldIntercept(anchor as HTMLAnchorElement)) {\n        event.preventDefault();\n        this.runCallback(\"onEnter\");\n        this.navigate(anchor.href);\n      }\n    });\n  }\n\n  /**\n   * @description This method checks if the\n   * anchor should be intercepted based on\n   * the current URL and the anchor's href.\n   */\n  private shouldIntercept(anchor: HTMLAnchorElement): boolean {\n    this.options.debug ? console.log(\"started -> shouldIntercept() Method\") : null;\n\n    const currentUrl = new URL(window.location.href);\n    const linkUrl = new URL(anchor.href);\n\n    // Check if it's an internal link\n    const isSameOrigin = linkUrl.origin === currentUrl.origin;\n\n    // Check if it's not the current page or just a hash change\n    const isSamePage = linkUrl.pathname === currentUrl.pathname && linkUrl.search === currentUrl.search;\n    const isJustHashChange = isSamePage && linkUrl.hash !== currentUrl.hash;\n\n    // Intercept only if it's an internal link and not the same page or just a hash change\n    return isSameOrigin && !isSamePage && !isJustHashChange;\n  }\n\n  /**\n   * @description This method handles popstate events\n   * to support back and forward navigation.\n   */\n  private handlePopState() {\n    this.options.debug ? console.log(\"started -> handlePopState() Method\") : null;\n\n    window.addEventListener(\"popstate\", () => {\n      this.navigate(window.location.href, false);\n    });\n  }\n\n  /**\n   * @description This method navigates to the given URL\n   * and updates the page content. If prefetching is enabled\n   * and the content is already prefetched, it uses the\n   * prefetched content instead of fetching it again.\n   * If pushState is true, it updates the browser history.\n   */\n  public async navigate(url: string, pushState: boolean = true) {\n    this.options.debug ? console.log(\"started -> navigate() Method\") : null;\n\n    try {\n      let content: string | null = null;\n      if (this.prefetcher) {\n        content = this.prefetcher.getContent(url);\n      }\n\n      if (!content) {\n        content = await this.fetchPage(url);\n      }\n\n      if (content) {\n        if (pushState) {\n          history.pushState(null, \"\", url);\n        }\n        this.updatePage(content);\n      }\n    } catch (error) {\n      this.options.debug ? console.error(\"Navigation failed:\", error) : null;\n    }\n  }\n\n  /**\n   * @description This method fetches the content of the given URL\n   * and returns it as a string. It throws an error if the request fails.\n   */\n  private async fetchPage(url: string): Promise<string> {\n    this.options.debug ? console.log(\"started -> fetchPage() Method\") : null;\n\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    return await response.text();\n  }\n\n  /**\n   * @description This method updates the page content\n   * with the new content fetched from the server.\n   * It updates the head and body of the document\n   * based on the new content.\n   */\n  private async updatePage(content: string) {\n    this.options.debug ? console.log(\"started -> updatePage() Method\") : null;\n\n    const parser = new DOMParser();\n    const newDoc = parser.parseFromString(content, \"text/html\");\n\n    await this.updateBody(newDoc);\n    this.updateHead(newDoc);\n  }\n\n  /**\n   * @description This method updates the head of the document\n   * with the new head from the fetched content. It updates\n   * the title and other head elements based on the new content.\n   */\n  private updateHead(newDoc: Document) {\n    this.options.debug ? console.log(\"started -> updateHead() Method\") : null;\n\n    const oldHead = document.head;\n    const newHead = newDoc.head;\n\n    // Always update the title\n    document.title = newDoc.title;\n\n    if (this.options.head?.update === false) {\n      return;\n    }\n\n    // Remove old elements except our style element and title\n    Array.from(oldHead.children).forEach((child) => {\n      if (child !== this.styleElement && child.tagName !== \"TITLE\") {\n        child.remove();\n      }\n    });\n\n    // Add new elements\n    Array.from(newHead.children).forEach((child) => {\n      if (child.tagName !== \"STYLE\" && child.tagName !== \"TITLE\") {\n        const newChild = child.cloneNode(true) as HTMLElement;\n        oldHead.appendChild(newChild);\n        this.retriggerElement(newChild);\n      }\n    });\n\n    this.options.debug ? console.log(\"Head updated, xref style element preserved\") : null;\n  }\n\n  private retriggerElement(element: HTMLElement) {\n    const { retrigger } = this.options.head || {};\n    if (!retrigger) return;\n\n    const shouldRetrigger = (el: HTMLElement): boolean => {\n      if (retrigger.include && !el.matches(retrigger.include.toString())) return false;\n      if (retrigger.exclude && el.matches(retrigger.exclude.toString())) return false;\n      return true;\n    };\n\n    if (element.tagName === \"LINK\" && retrigger.css && shouldRetrigger(element)) {\n      const link = element as HTMLLinkElement;\n      link.href = link.href.split(\"?\")[0] + \"?t=\" + new Date().getTime();\n    } else if (element.tagName === \"SCRIPT\" && retrigger.js && shouldRetrigger(element)) {\n      const script = element as HTMLScriptElement;\n      const newScript = document.createElement(\"script\");\n      Array.from(script.attributes).forEach((attr) => newScript.setAttribute(attr.name, attr.value));\n      newScript.textContent = script.textContent;\n      script.parentNode?.replaceChild(newScript, script);\n    }\n  }\n\n  /**\n   * @description This method updates the body of the document\n   * with the new body from the fetched content. It updates\n   * the content of the swapHtml element based on the new content.\n   * It also performs the transition between the old and new content.\n   */\n  private async updateBody(newDoc: Document) {\n    this.options.debug ? console.log(\"started -> updateBody() Method\") : null;\n\n    const swapHtml = this.options.transition?.swapHtml || \"body\";\n    const oldElement = document.querySelector(swapHtml);\n    const newElement = newDoc.querySelector(swapHtml);\n\n    if (!oldElement || !newElement) {\n      this.options.debug ? console.error(`Element not found: ${swapHtml}`) : null;\n      return;\n    }\n\n    await this.performTransition(oldElement as HTMLElement, newElement as HTMLElement);\n\n    window.scrollTo(0, 0);\n  }\n\n  /**\n   * @description This method performs the transition\n   * between the old and new content by applying the\n   * in and out transitions to the elements.\n   * It also handles the transition timeline, duration,\n   * delay, and easing.\n   */\n  private async performTransition(oldElement: HTMLElement, newElement: HTMLElement) {\n    this.options.debug ? console.log(\"Started performTransition\") : null;\n    const transitionOptions = this.options.transition || {};\n    const duration = transitionOptions.duration || 300;\n    const delay = transitionOptions.delay || 0;\n    const easing = transitionOptions.easing || \"ease-in-out\";\n\n    let outTransition = transitionOptions.out;\n    let inTransition = transitionOptions.in;\n\n    this.setTransitionState(\"started\", true);\n    this.runCallback(\"onStart\");\n\n    // Get partials outside swapHtml\n    const partialsOutsideSwapHtml = this.getPartialsOutsideSwapHtml();\n\n    // 1. Animate partials \"out\"\n    if (partialsOutsideSwapHtml.length > 0) {\n      this.options.debug ? console.log(\"Applying partial out transitions\") : null;\n      const partialsOutPromise = handlePartials(partialsOutsideSwapHtml, document.body, document.body, this.options, \"out\");\n\n      // Wait for the longest partial out animation to complete\n      await partialsOutPromise;\n\n      // Hide partials after out animations\n      hidePartials(partialsOutsideSwapHtml, document.body);\n    }\n\n    // 2. Animate swapHtml out\n    if (outTransition) {\n      this.options.debug ? console.log(\"Applying main out transition\") : null;\n      await this.applyTransition(oldElement, outTransition, duration, delay, easing, \"out\");\n    }\n\n    // Update content of swapHtml\n    oldElement.innerHTML = newElement.innerHTML;\n    Array.from(newElement.attributes).forEach((attr) => {\n      if (attr.name !== \"style\") {\n        oldElement.setAttribute(attr.name, attr.value);\n      }\n    });\n\n    // 3. Animate swapHtml in\n    if (inTransition) {\n      this.options.debug ? console.log(\"Applying main in transition\") : null;\n      await this.applyTransition(oldElement, inTransition, duration, delay, easing, \"in\");\n    }\n\n    // 4. Animate partials \"in\"\n    if (partialsOutsideSwapHtml.length > 0) {\n      hidePartials(partialsOutsideSwapHtml, document.body);\n      await handlePartials(partialsOutsideSwapHtml, document.body, document.body, this.options, \"in\");\n    }\n\n    // 5. Partials visible and DOM is ready with new Page\n    this.setTransitionState(\"finished\", true);\n    this.runCallback(\"onFinish\");\n\n    window.scrollTo(0, 0);\n  }\n\n  private getPartialsOutsideSwapHtml(): PartialTransition[] {\n    const swapHtml = this.options.transition?.swapHtml || \"body\";\n    const swapHtmlElement = document.querySelector(swapHtml);\n\n    return (this.options.transition?.partials || []).filter((partial) => {\n      const elements = document.querySelectorAll(partial.element);\n      return Array.from(elements).every((el) => !swapHtmlElement?.contains(el));\n    });\n  }\n\n  /**\n   * @description This method reverses the given transition\n   * by swapping the from and to states. This is useful\n   * for creating the \"out\" transition from the \"in\" transition.\n   */\n  private reverseTransition(transition: TransitionState): TransitionState {\n    return {\n      from: transition.to,\n      to: transition.from,\n    };\n  }\n\n  /**\n   * @description This method applies the transition to the element\n   * by creating the keyframes, setting the animation properties,\n   * and cleaning up after the animation is complete.\n   */\n  private applyTransition(element: HTMLElement, transitionState: TransitionState, duration: number, delay: number, easing: string, direction: \"in\" | \"out\"): Promise<void> {\n    return new Promise((resolve) => {\n      this.options.debug ? console.log(`Applying ${direction} transition`) : null;\n      const keyframeName = this.createKeyframes(transitionState, direction);\n      const animationCSS = `${keyframeName} ${duration}ms ${easing} ${delay}ms forwards`;\n\n      element.style.setProperty(\"animation\", animationCSS);\n      this.options.debug ? console.log(`Applied ${direction} animation: ${animationCSS}`) : null;\n      this.options.debug ? console.log(\"Current element style:\", element.style.cssText) : null;\n\n      // Force a reflow to ensure the animation is applied immediately\n      void element.offsetWidth;\n\n      const cleanup = () => {\n        this.options.debug ? console.log(`Animation end event fired for ${direction} transition`) : null;\n        element.style.removeProperty(\"animation\");\n\n        // Remove the keyframe immediately after the animation is complete\n        this.removeKeyframes(keyframeName);\n\n        if (direction === \"in\") {\n          Object.entries(transitionState.to || {}).forEach(([key, value]) => {\n            element.style.setProperty(camelToKebab(key), value as string);\n          });\n        }\n        this.options.debug ? console.log(`Cleaned up ${direction} animation`) : null;\n        this.options.debug ? console.log(\"Current element style after cleanup:\", element.style.cssText) : null;\n\n        resolve();\n      };\n\n      element.addEventListener(\"animationend\", cleanup, { once: true });\n    });\n  }\n\n  /**\n   * @description This method sets the transition state\n   * based on the given key and value. This is useful\n   * for tracking the state of the transition.\n   */\n  private setTransitionState(key: keyof AnimationState, value: boolean) {\n    this.animationState[key] = value;\n  }\n\n  private runCallback(callbackName: keyof TransitionCallbacks) {\n    const callback = this.options.transition?.callback?.[callbackName];\n    if (callback && typeof callback === \"function\") {\n      callback();\n    }\n  }\n\n  /**\n   * @description This method starts the transition\n   * and sets the animation state accordingly.\n   */\n  public startTransition() {\n    this.setTransitionState(\"started\", true);\n    this.setTransitionState(\"playing\", true);\n    this.setTransitionState(\"paused\", false);\n    this.setTransitionState(\"finished\", false);\n    this.runCallback(\"onStart\");\n    this.runCallback(\"onPlay\");\n  }\n\n  /**\n   * @description This method pauses the transition\n   * and sets the animation state accordingly.\n   */\n  public pauseTransition() {\n    if (this.animationState.playing) {\n      this.setTransitionState(\"playing\", false);\n      this.setTransitionState(\"paused\", true);\n      this.runCallback(\"onPause\");\n\n      // Pause transition\n      const element = document.querySelector(this.options.transition?.swapHtml || \"body\");\n      if (element instanceof HTMLElement) {\n        element.style.animationPlayState = \"paused\";\n      }\n    }\n  }\n\n  /**\n   * @description This method resumes the transition\n   * and sets the animation state accordingly.\n   */\n  public resumeTransition() {\n    if (this.animationState.paused) {\n      this.setTransitionState(\"playing\", true);\n      this.setTransitionState(\"paused\", false);\n      this.runCallback(\"onPlay\");\n\n      // Play transition\n      const element = document.querySelector(this.options.transition?.swapHtml || \"body\");\n      if (element instanceof HTMLElement) {\n        element.style.animationPlayState = \"running\";\n      }\n    }\n  }\n\n  /**\n   * @description This method finishes the transition\n   * and cleans up the animation\n   * */\n  public finishTransition() {\n    this.setTransitionState(\"playing\", false);\n    this.setTransitionState(\"paused\", false);\n    this.setTransitionState(\"finished\", true);\n    this.runCallback(\"onFinish\");\n  }\n}\n\nfunction xref(options: XrefOptions = {}): Xref {\n  return new Xref(options);\n}\n\nexport default xref;\n"],"names":["Prefetcher","constructor","options","xrefOptions","this","cache","Map","init","active","document","addEventListener","event","handleEvent","bind","link","target","closest","selector","shouldPrefetch","setTimeout","prefetch","href","delay","startsWith","window","location","origin","has","url","response","fetch","text","set","debug","console","log","error","getContent","get","camelToKebab","str","replace","toLowerCase","async","handlePartials","partials","oldElement","newElement","direction","partialPromises","flatMap","partial","index","elements","querySelectorAll","element","length","Array","from","map","mergedOptions","globalTransition","globalPartial","_a","Object","assign","duration","_b","_c","easing","_d","mergeOptions","transition","transitionState","out","in","oppositeTransition","to","style","removeProperty","Promise","resolve","keyframeName","Math","random","toString","substr","keyframeCSS","entries","key","value","join","styleElement","createElement","textContent","head","appendChild","createKeyframes","animationCSS","setProperty","cssText","offsetWidth","cleanup","tagName","querySelector","remove","removeKeyframes","forEach","once","applyPartialTransition","all","hidePartials","el","visibility","Xref","transitionCounter","prefetcher","currentKeyframeName","updateHead","setAttribute","animationState","started","playing","paused","finished","state","interceptClicks","handlePopState","anchor","shouldIntercept","preventDefault","runCallback","navigate","currentUrl","URL","linkUrl","isSameOrigin","isSamePage","pathname","search","isJustHashChange","hash","pushState","content","fetchPage","history","updatePage","ok","Error","status","newDoc","DOMParser","parseFromString","updateBody","oldHead","newHead","title","update","children","child","newChild","cloneNode","retriggerElement","retrigger","shouldRetrigger","include","matches","exclude","css","split","Date","getTime","js","script","newScript","attributes","attr","name","parentNode","replaceChild","swapHtml","performTransition","scrollTo","transitionOptions","outTransition","inTransition","setTransitionState","partialsOutsideSwapHtml","getPartialsOutsideSwapHtml","partialsOutPromise","body","applyTransition","innerHTML","swapHtmlElement","filter","every","contains","reverseTransition","callbackName","callback","startTransition","pauseTransition","HTMLElement","animationPlayState","resumeTransition","finishTransition"],"mappings":"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"}