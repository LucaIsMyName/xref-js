{"version":3,"file":"xref.umd.min.js","sources":["../src/xref.ts"],"sourcesContent":["interface XrefOptions {\n  updateHead?: boolean;\n  swapHtml?: string;\n  transition?: TransitionOptions;\n}\n\ninterface TransitionOptions {\n  duration?: number;\n  delay?: number;\n  easing?: string;\n  timeline?: \"sequential\" | \"parallel\";\n  in?: TransitionState;\n  out?: TransitionState;\n}\n\ninterface TransitionState {\n  from?: Record<string, string | number>;\n  to?: Record<string, string | number>;\n}\n\nclass Xref {\n  private options: XrefOptions;\n  private styleElement: HTMLStyleElement;\n  private transitionCounter: number = 0;\n\n  constructor(options: XrefOptions = {}) {\n    this.options = {\n      updateHead: true,\n      ...options,\n    };\n    this.styleElement = document.createElement(\"style\");\n    this.styleElement.setAttribute(\"data-xref\", \"true\");\n    document.head.appendChild(this.styleElement);\n    this.init();\n  }\n\n  private init() {\n    console.log(\"started -> init() Method\");\n\n    this.interceptClicks();\n    this.handlePopState();\n  }\n\n  // private currentKeyframes: { in?: string; out?: string } = {};\n  private currentKeyframeName: string | null = null;\n\n\n  private createKeyframes(transitionState: TransitionState, direction: \"in\" | \"out\"): string {\n    const { from, to } = transitionState;\n    const keyframeName = `xref-${direction}-${++this.transitionCounter}`;\n\n    let keyframeCSS = `@keyframes ${keyframeName} {\n      from {\n        ${Object.entries(from || {})\n          .map(([key, value]) => `${this.camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n      to {\n        ${Object.entries(to || {})\n          .map(([key, value]) => `${this.camelToKebab(key)}: ${value};`)\n          .join(\" \")}\n      }\n    }`;\n\n    console.log(`Creating keyframe: ${keyframeName}`);\n    console.log(`Keyframe CSS: ${keyframeCSS}`);\n\n    // Remove the previous keyframe if it exists\n    if (this.currentKeyframeName) {\n      this.removeKeyframes(this.currentKeyframeName);\n    }\n\n    // Append the new keyframe to the style element's content\n    this.styleElement.textContent = keyframeCSS;\n    this.currentKeyframeName = keyframeName;\n\n    console.log(`Keyframe ${keyframeName} appended to <style> element`);\n    console.log(`Current <style> content: ${this.styleElement.textContent}`);\n\n    return keyframeName;\n  }\n\n\n  private removeKeyframes(keyframeName: string) {\n    console.log(`Removing keyframe: ${keyframeName}`);\n    this.styleElement.textContent = '';\n    console.log(`Keyframe ${keyframeName} removed`);\n    console.log(`Current <style> content after removal: ${this.styleElement.textContent}`);\n    this.currentKeyframeName = null;\n  }\n\n  private removeUnusedKeyframes() {\n    // remove all keyframes inside <style data-xref>\n    console.log(\"started -> removeUnusedKeyframes() Method\");\n\n    const keyframeRegex = /@keyframes\\s+xref-(in|out)-\\d+\\s*{[^}]*}/gs;\n    this.styleElement.textContent = this.styleElement.textContent.replace(keyframeRegex, \"\");\n    console.log(\"Removed all keyframes\");\n  }\n  private removeInlineStylesFromRoot() {\n    console.log(\"started -> removeInlineStylesFromRoot() Method\");\n\n    /**\n     * remove the transitioned nline styles from the swapHtml element\n     */\n\n    const swapHtml = this.options.swapHtml || \"body\";\n    const rootElement = document.querySelector(swapHtml);\n    if (!rootElement) {\n      return;\n    }\n\n    rootElement.setAttribute(\"style\", '');\n  }\n\n  private interceptClicks() {\n    console.log(\"started -> interceptClicks() Method\");\n\n    document.addEventListener(\"click\", (event) => {\n      const target = event.target as HTMLElement;\n      const anchor = target.closest(\"a\");\n      if (anchor && this.shouldIntercept(anchor)) {\n        event.preventDefault();\n        this.navigate(anchor.href);\n      }\n    });\n  }\n\n  private shouldIntercept(anchor: HTMLAnchorElement): boolean {\n    console.log(\"started -> shouldIntercept() Method\");\n\n    const isSameOrigin = anchor.origin === window.location.origin;\n    const isNotHash = anchor.hash === \"\";\n    return isSameOrigin && isNotHash;\n  }\n\n  private handlePopState() {\n    console.log(\"started -> handlePopState() Method\");\n\n    window.addEventListener(\"popstate\", () => {\n      this.navigate(window.location.href, false);\n    });\n  }\n\n  public async navigate(url: string, pushState: boolean = true) {\n    console.log(\"started -> navigate() Method\");\n\n    try {\n      const content = await this.fetchPage(url);\n      if (content) {\n        if (pushState) {\n          history.pushState(null, \"\", url);\n        }\n        this.updatePage(content);\n      }\n    } catch (error) {\n      console.error(\"Navigation failed:\", error);\n    }\n  }\n  private async fetchPage(url: string): Promise<string> {\n    console.log(\"started -> fetchPage() Method\");\n\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    return await response.text();\n  }\n\n  private updatePage(content: string) {\n    console.log(\"started -> updatePage() Method\");\n\n    const parser = new DOMParser();\n    const newDoc = parser.parseFromString(content, \"text/html\");\n\n    this.updateHead(newDoc);\n    this.updateBody(newDoc);\n  }\n\n  private updateHead(newDoc: Document) {\n    console.log(\"started -> updateHead() Method\");\n\n    const oldHead = document.head;\n    const newHead = newDoc.head;\n\n    // Always update the title\n    document.title = newDoc.title;\n\n    // If updateHead is false, don't update anything else in the head\n    if (this.options.updateHead === false) {\n      return;\n    }\n\n    // Remove old elements except our style element and title\n    Array.from(oldHead.children).forEach((child) => {\n      if (child !== this.styleElement && child.tagName !== \"TITLE\") {\n        child.remove();\n      }\n    });\n\n    // Add new elements\n    Array.from(newHead.children).forEach((child) => {\n      if (child.tagName !== \"STYLE\" && child.tagName !== \"TITLE\") {\n        oldHead.appendChild(child.cloneNode(true));\n      }\n    });\n\n    console.log(\"Head updated, xref style element preserved\");\n  }\n\n  private updateBody(newDoc: Document) {\n    console.log(\"started -> updateBody() Method\");\n\n    const swapHtml = this.options.swapHtml || \"body\";\n    const oldElement = document.querySelector(swapHtml);\n    const newElement = newDoc.querySelector(swapHtml);\n\n    if (!oldElement) {\n      console.error(`Old document does not contain element: ${swapHtml}`);\n      return;\n    }\n\n    if (!newElement) {\n      console.error(`New document does not contain element: ${swapHtml}`);\n      return;\n    }\n\n    // Type assertions\n    this.performTransition(oldElement as HTMLElement, newElement as HTMLElement);\n    /* this.removeInlineStylesFromRoot(); */\n  }\n\n  private performTransition(oldBody: HTMLElement, newBody: HTMLElement) {\n    console.log(\"Started performTransition\");\n    const transitionOptions = this.options.transition || {};\n    const duration = transitionOptions.duration || 300;\n    const delay = transitionOptions.delay || 0;\n    const easing = transitionOptions.easing || \"ease-in-out\";\n    const timeline = transitionOptions.timeline || \"sequential\";\n\n    let outTransition = transitionOptions.out;\n    let inTransition = transitionOptions.in;\n\n    // If no out transition is set, reverse the in transition\n    if (!outTransition && inTransition) {\n      outTransition = this.reverseTransition(inTransition);\n    }\n    // If no in transition is set, reverse the out transition\n    else if (!inTransition && outTransition) {\n      inTransition = this.reverseTransition(outTransition);\n    }\n\n    console.log(\"Transition options:\", { duration, delay, easing, timeline });\n    console.log(\"Out transition:\", outTransition);\n    console.log(\"In transition:\", inTransition);\n\n    if (outTransition) {\n      console.log(\"Applying out transition\");\n      this.applyTransition(oldBody, outTransition, duration, delay, easing, \"out\");\n    }\n\n    const applyInTransition = () => {\n      console.log(\"Applying in transition\");\n      // Remove the \"out\" animation\n      oldBody.style.removeProperty('animation');\n      \n      oldBody.innerHTML = newBody.innerHTML;\n      Array.from(newBody.attributes).forEach((attr) => {\n        if (attr.name !== \"style\") {\n          oldBody.setAttribute(attr.name, attr.value);\n        }\n      });\n\n      if (inTransition) {\n        this.applyTransition(oldBody, inTransition, duration, 0, easing, \"in\");\n      }\n    };\n\n    if (timeline === \"sequential\") {\n      console.log(`Setting timeout for in transition: ${duration + delay}ms`);\n      setTimeout(applyInTransition, duration / 2 + delay);\n    } else {\n      console.log(`Setting timeout for in transition: ${delay}ms (parallel)`);\n      setTimeout(applyInTransition, delay);\n    }\n  }\n\n\n  private reverseTransition(transition: TransitionState): TransitionState {\n    return {\n      from: transition.to,\n      to: transition.from,\n    };\n  }\n\n  private applyTransition(element: HTMLElement, transitionState: TransitionState, duration: number, delay: number, easing: string, direction: \"in\" | \"out\") {\n    console.log(`Applying ${direction} transition`);\n    const keyframeName = this.createKeyframes(transitionState, direction);\n    const animationCSS = `${keyframeName} ${duration}ms ${easing} ${delay}ms forwards`;\n\n    // Ensure we're setting the animation property correctly\n    element.style.setProperty('animation', animationCSS);\n    console.log(`Applied ${direction} animation: ${animationCSS}`);\n    console.log(`Current element style:`, element.style.cssText);\n\n    // Force a reflow to ensure the animation is applied immediately\n    void element.offsetWidth;\n\n    const cleanup = () => {\n      console.log(`Animation end event fired for ${direction} transition`);\n      element.style.removeProperty('animation');\n\n      // Remove the keyframe immediately after the animation is complete\n      this.removeKeyframes(keyframeName);\n\n      if (direction === \"in\") {\n        Object.entries(transitionState.to || {}).forEach(([key, value]) => {\n          element.style.setProperty(this.camelToKebab(key), value as string);\n        });\n      }\n      console.log(`Cleaned up ${direction} animation`);\n      console.log(`Current element style after cleanup:`, element.style.cssText);\n      element.removeEventListener(\"animationend\", cleanup);\n    };\n\n    element.addEventListener(\"animationend\", cleanup, { once: true });\n  }\n\n  public camelToKebab(str: string): string {\n    return str.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n  }\n}\n\nfunction xref(options: XrefOptions = {}): Xref {\n  return new Xref(options);\n}\n\nexport default xref;\n"],"names":["Xref","constructor","options","this","transitionCounter","currentKeyframeName","Object","assign","updateHead","styleElement","document","createElement","setAttribute","head","appendChild","init","console","log","interceptClicks","handlePopState","createKeyframes","transitionState","direction","from","to","keyframeName","keyframeCSS","entries","map","key","value","camelToKebab","join","removeKeyframes","textContent","removeUnusedKeyframes","replace","removeInlineStylesFromRoot","swapHtml","rootElement","querySelector","addEventListener","event","anchor","target","closest","shouldIntercept","preventDefault","navigate","href","isSameOrigin","origin","window","location","isNotHash","hash","url","pushState","content","fetchPage","history","updatePage","error","response","fetch","ok","Error","status","text","newDoc","DOMParser","parseFromString","updateBody","oldHead","newHead","title","Array","children","forEach","child","tagName","remove","cloneNode","oldElement","newElement","performTransition","oldBody","newBody","transitionOptions","transition","duration","delay","easing","timeline","outTransition","out","inTransition","in","reverseTransition","applyTransition","applyInTransition","style","removeProperty","innerHTML","attributes","attr","name","setTimeout","element","animationCSS","setProperty","cssText","offsetWidth","cleanup","removeEventListener","once","str","toLowerCase"],"mappings":"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"}